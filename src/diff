diff -rubN epos-2.4/src/common.h usr/src/common.h
--- epos-2.4/src/common.h	Fri Nov 23 21:43:04 2001
+++ usr/src/common.h	Tue May  7 21:52:08 2002
@@ -27,7 +27,7 @@
 
 #define MAINTAINER  		"Jirka Hanika"
 #define MAIL        		"geo@cuni.cz"
-#define VERSION     		"2.4.73"
+#define VERSION     		"2.4.75"
 #define TTSCP_PORT		 8778
 
 #include "config.h"
diff -rubN epos-2.4/src/encoding.cc usr/src/encoding.cc
--- epos-2.4/src/encoding.cc	Sun Nov  4 18:00:28 2001
+++ usr/src/encoding.cc	Tue May  7 21:52:08 2002
@@ -88,7 +88,7 @@
 	}
 	DEBUG(2,10,fprintf(STDDBG, "Want to allocate charcode unicode %d, original enc %d\n", c, hint);)
 	shriek(447, "Epos internal character table overflow");
-
+	return UNDEFINED;
 }
 
 static inline unsigned char alloc_code(wchar_t c, unsigned char hint, int cs)
diff -rubN epos-2.4/src/options.lst usr/src/options.lst
--- epos-2.4/src/options.lst	Sun Nov  4 15:49:10 2001
+++ usr/src/options.lst	Tue May  7 21:52:08 2002
@@ -444,6 +444,9 @@
 
 VOICE_OPTION (inv_out_rate, out_rate, "out_sampling_rate", INT, 0)	// 0 means equal to samp_rate
 	// positive value specifies the required output rate (samp_rate divided by an integer)
+//VOICE_OPTION (f0_model, f0_model, "f0_modelling", STR, "classic")	// F0 contour modelling (classic, lpc, fujisaki)
+VOICE_OPTION (lpcprosody, lpcprosody, "lpcprosody", BOOL, false)	// F0 contour modelling using a linear prediction
+
 OPTION (autofilter, "autofilter", BOOL, true)	// When downsampling, band filter as necessary
 
 OPTION (wav_hdr, "wave_header",	  BOOL, true)   // Should .wav output contain .wav file header?
diff -rubN epos-2.4/src/rule.cc usr/src/rule.cc
--- epos-2.4/src/rule.cc	Sun Nov  4 17:45:40 2001
+++ usr/src/rule.cc	Tue May  7 21:52:08 2002
@@ -16,6 +16,8 @@
  *
  */
 
+#include <windows.h>
+
 #include "common.h"
 
 #define DIPH_BUFF_SIZE  1000 //unimportant
@@ -863,10 +865,14 @@
  **	  is applied
  ************************************************/
 
+//typedef UINT (CALLBACK* TSR_EVAL)(unit*);
+
+typedef int (*TSR_EVAL)(unit*);
 
 class r_debug: public rule
 {
 	virtual OPCODE code() {return OP_DEBUG;};
+	TSR_EVAL tsr_eval;
    public:
 		r_debug(char *param);
 	virtual void apply(unit *root);
@@ -879,6 +885,19 @@
 void
 r_debug::apply(unit *root)
 {
+	if(strstr(raw,"tsrtool")) {
+#ifdef HAVE_MMSYSTEM_H		// The TSR debuging tool is up to now available only in the M$WIN port of the epos
+		HINSTANCE hDLL = LoadLibrary("tsrtool.dll");
+		if (hDLL != NULL)
+		{
+			tsr_eval = (TSR_EVAL)GetProcAddress(hDLL,"_tsr_eval");
+			if (!tsr_eval) shriek(445, "cannot get 'tsr_eval' function from tsrtool.dll");
+			//root->fout(NULL);
+			//printf("tsr_eval...\n");
+			tsr_eval(root);
+		}
+#endif
+	}
 	if(strstr(raw,"elem")) root->fout(NULL);
 //	if(strstr(raw,"rules")) ruleset->debug();
 //	else if(strstr(raw,"rule") && ruleset->current_rule+1 < ruleset->n_rules)
diff -rubN epos-2.4/src/tdpsyn.cc usr/src/tdpsyn.cc
--- epos-2.4/src/tdpsyn.cc	Mon Nov 12 05:27:23 2001
+++ usr/src/tdpsyn.cc	Tue May  7 21:52:08 2002
@@ -1,9 +1,9 @@
 /*
  * 	epos/src/tdpsyn.cc
- * 	(c) 2000-2001 Petr Horak, petr.horak@click.cz
- * 	(c) 2001 Jirka Hanika, geo@cuni.cz
+ * 	(c) 2000-2002 Petr Horak, horak@petr.cz
+ * 	(c) 2001-2002 Jirka Hanika, geo@cuni.cz
  *
- *	tdpsyn version 2.1 (8.11.2001)
+ *	tdpsyn version 2.3.3 (25.4.2002)
  *
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -23,9 +23,26 @@
 #include <math.h>
 
 #define MAX_STRETCH	30	/* stretching beyond 30 samples per OLA frame must be done through repeating frames */
-#define MAX_OLA_FRAME	1024	/* sanity check only */
+#define MAX_OLA_FRAME	4096	/* sanity check only */
 #define HAMMING_PRECISION 15	/* hamming coefficient precision in bits */
+#define LP_F0_STEP 8			/* step of F0 analysis for linear prediction */
+#define LP_DECIM 10				/* F0 analysis decimation coeff. for linear prediction */
+#define LP_F0_ORD 4				/* order of F0 contour LP analysis */
+#define F0_FILT_ORD 9			/* F0 contour filter order */
+#define LP_EXC_MUL 1.33			/* LP excitation multipicator */
+
+/* F0 contour filter coefficients */
+const double a[9] = {1,-6.46921563821389,18.43727805607084,-30.21344177474595,31.11962012720199,
+					-20.62061607537661,8.58111044795433,-2.04983423923570,0.21516477151414};
+
+const double b[9] = {0.01477848982115,-0.08930749676388,0.25181616063735,-0.43840842338467,0.52230821454923,
+					-0.43840842338467,0.25181616063735,-0.08930749676388,0.01477848982115};
+
+/* lp f0 contour filter coefficients (mean of 144 sentences from speaker Machac) */
+const double lp[LP_F0_ORD] = {-1.23761, 0.60009, -0.32046, 0.10699};
+// FIXME! lp coefficients must be configurable
 
+/* Hamming coefficients for TD-PSOLA algorithm */
 int hamkoe(int winlen, unsigned short *data, int e, int e_base)
 {
 	int i;
@@ -43,7 +60,6 @@
 int hamkoe(int winlen, double *data)
 {
 //	printf("%d\n", winlen);
-
 	int i;
 	double fn;
 	fn = 2 * pii / (winlen - 1);
@@ -64,6 +80,7 @@
 #endif
 
 
+/* Inventory file header structure */
 struct tdi_hdr
 {
 	int magic;
@@ -96,19 +113,34 @@
 	ppulses = diph_len + v->n_segs;
 
 	/* allocate the maximum necessary space for Hamming windows: */	
-	max_frame = 0;
-	for (int k = 0; k < v->n_segs; k++) {
-		int avpitch = average_pitch(diph_offs[k], diph_len[k]);
-		int maxwin = avpitch + MAX_STRETCH; //(int)(w->samp_rate / 500);
-		if (max_frame < maxwin) max_frame = maxwin;
-	}
-	max_frame++;
-	if (max_frame >= MAX_OLA_FRAME || max_frame == 0) shriek(463, "Inconsistent OLA frame buffer size");
+//	max_frame = 0;
+//	for (int k = 0; k < v->n_segs; k++) {
+//		int avpitch = average_pitch(diph_offs[k], diph_len[k]);
+//		int maxwin = avpitch + MAX_STRETCH; //(int)(w->samp_rate / 500);
+//		if (max_frame < maxwin) max_frame = maxwin;
+//	}
+//	max_frame++;
+//	if (max_frame >= MAX_OLA_FRAME || max_frame == 0) shriek(463, "Inconsistent OLA frame buffer size");
+	//FIXME! max_frame=maxwin * (max_L - min_ori_L)
+
+	max_frame = MAX_OLA_FRAME;
+	
 	wwin = (unsigned short *)xmalloc(sizeof(unsigned short) * (max_frame * 2));
 	memset(wwin, 0, (max_frame * 2) * sizeof(*wwin));
 
 	out_buff = (t_samp *)xmalloc(sizeof(t_samp) * max_frame * 2);
 	memset(out_buff, 0, max_frame * 2 * sizeof(*out_buff));
+
+	/* initialisation of lp prosody engine */
+	if (v->lpcprosody) {
+		for (int i = 0; i < LPC_PROS_ORDER; lpfilt[i++] = 0);
+		for (i = 0; i < MAX_OFILT_ORDER; ofilt[i++] = 0);
+		sigpos = 0;
+		lppstep = LP_F0_STEP * v->samp_rate / 1000;
+		lpestep = LP_DECIM * lppstep;
+		basef0 = v->init_f;
+		lppitch = v->samp_rate / basef0;;
+	}
 }
 
 tdpsyn::~tdpsyn(void)
@@ -139,40 +171,48 @@
 	return total / i;
 }
 
-void tdpsyn::synseg(voice *, segment d, wavefm *w)
+void tdpsyn::synseg(voice *v, segment d, wavefm *w)
 {
-	int i, j, pitch, avpitch, pitchlen, origlen, newlen, maxwin, step, diflen;
+	int i, j, k, l, m, slen, nlen, pitch, avpitch, origlen, newlen, maxwin, skip, reply, diflen;
+	double outf0, synf0, exc;
 	t_samp poms;
 	
 	const int max_frame = this->max_frame;
 
 	if (diph_len[d.code] == 0) {
-		DEBUG(2,9, fprintf(STDDBG, "missing diphone: %d\n", d.code);)
+		DEBUG(2,9, fprintf(STDDBG, "missing speech unit No: %d\n", d.code);)
 		if (!cfg->paranoid) return;
-		shriek(463, fmt("missing diphone: %d\n",d.code));
+		shriek(463, fmt("missing speech unit No: %d\n",d.code));
 	}
 
-	avpitch = average_pitch(diph_offs[d.code], diph_len[d.code]);
-	maxwin = avpitch + MAX_STRETCH; //(int)(w->samp_rate / 500);
+	/* lp prosody reconstruction filter excitation signal computing */
+	if (v->lpcprosody) { 	// in d.f is excitation signal value
+		exc = LP_EXC_MUL * (100 * v->samp_rate / d.f / v->init_f - 100);
+		pitch = lppitch;
+	}
+	else					// in d.f is f0 contour value
 	pitch = d.f;
+	slen = diph_len[d.code];
+	avpitch = average_pitch(diph_offs[d.code], slen);
+	maxwin = avpitch + MAX_STRETCH;
 	maxwin = (pitch > maxwin) ? maxwin : pitch;
 	if (maxwin >= max_frame) shriek(461, "pitch too large");
 
-	origlen = avpitch * diph_len[d.code];
-	pitchlen = pitch * diph_len[d.code];
-	newlen = origlen * 100 / d.t;
-	diflen = (newlen - origlen) / diph_len[d.code] % pitch;
-//	printf("\navp=%d oril=%d newl=%d difl=%d| l:%d t:%f(%f) e:%f\n",avpitch,origlen,newlen,diflen,pitch,tim_k,(double)d.t/100,ene_k);
-//	printf("\navp=%d L=%d oril=%d pil=%d tk:%f newl=%d difl=%d| %d (%d)\n",avpitch,pitch,origlen,pitchlen,tim_k,newlen,diflen,diph_len[d.code],d.code);
+	if (d.t > 0) origlen = avpitch * slen * d.t / 100; else origlen = avpitch * slen;
+	newlen = pitch * slen;
+	//diflen = (newlen - origlen) / slen;
+	//printf("\navp=%d L=%d oril=%d newl=%d | %d (%d)\n",avpitch,pitch,origlen,newlen,diph_len[d.code],d.code);
+	//printf("unit:%4d f=%3d i=%3d t=%3d - pitch=%d\n",d.code,d.f,d.e,d.t,pitch);
 
 	hamkoe(2 * maxwin + 1, wwin, d.e, 100);
-//	step = 1;
-	step = abs((newlen - origlen) / diph_len[d.code] / pitch) + 1;
-//	diflen %= pitch;
-//	while (diflen > pitch) { step++; diflen -= pitch; }	// !!
-//	while (-diflen > pitch) { step++; diflen += pitch; }	// !!
-//	if (step != step2) shriek(999, fmt("steps %d %d", step, step2));
-	for (j = 1; j <= diph_len[d.code]; j += step) {
+	skip = 1; reply = 1;
+	if (newlen > origlen) skip = newlen / origlen;
+	if (origlen > newlen) reply = origlen / newlen;
+	//printf("dlen=%d p:%d avp=%d oril=%d newl=%d difl=%d",diph_len[d.code],pitch,avpitch,origlen,newlen,diflen);
+	nlen = slen - (skip - 1) * slen / skip + (reply - 1) * slen;
+	diflen = (newlen - origlen - (skip - 1) * slen * pitch / skip + (reply - 1) * slen * pitch) / nlen;
+	//printf(" -> diflen:%d sk:%d rp:%d\n",diflen,skip,reply);
+	for (j = 1; j <= diph_len[d.code]; j += skip) for (k = 0; k < reply; k++) {
 		memcpy(out_buff + max_frame - pitch, out_buff + max_frame, pitch * sizeof(*out_buff));
 		memset(out_buff + max_frame, 0, max_frame * sizeof(*out_buff));
 		for (i = -maxwin;i <= maxwin; i++) {
@@ -181,10 +221,52 @@
 //			poms = poms * d.e / 100;
 			out_buff[max_frame + i] += poms;
 		}
-//		for (i = max_frame - pitch; i < max_frame; i++) w->sample(out_buff[i]);
+
+		/* lpc synthesis of F0 contour */
+		if (v->lpcprosody) {
+			synf0 = 0; outf0 = 0;
+			for (l = 0; l < 2 * pitch; l++) {
+				sigpos++;
+				if (!(sigpos % lppstep)) {	// new pitch value into f0 output filter
+					//printf("LPP position point %d, exc=%.2f synf0=%d otf0=%.2f L=%d\n",sigpos,exc,synf0,outf0,lppitch);
+					synf0 = 0;
+					if (!(sigpos % lpestep)) {	// new excitation value into recontruction filter
+						//printf("   >> LPE position point %d (exc=%.4f) <<   \n",sigpos,exc);
+						//printf("lp=[%.3f %.3f %.3f %.3f] lpfilt=[%.3f %.3f %.3f %.3f]\n",lp[0],lp[1],lp[2],lp[3],lpfilt[0],lpfilt[1],lpfilt[2],lpfilt[3]);
+						synf0 = exc - lpfilt[0]*lp[0];
+						exc = 0;
+						for (m = LP_F0_ORD - 1; m > 0; m--) {
+							synf0 -= lp[m] * lpfilt[m];
+							lpfilt[m] = lpfilt[m-1];
+						}
+						lpfilt[0] = synf0;
+					}
+					ofilt[0] = synf0;
+					synf0 = 0;
+					for (m = 1; m < F0_FILT_ORD; m++) ofilt[0] -= a[m] * ofilt[m];
+					outf0 = 0;
+					for (m = 0; m < F0_FILT_ORD; m++) outf0 += b[m] * ofilt[m];
+					//printf("of=[%.3f %.3f %.3f %.3f %.3f %.3f %.3f %.3f %.3f]\n",ofilt[0],ofilt[1],
+					//	ofilt[2],ofilt[3],ofilt[4],ofilt[5],ofilt[6],ofilt[7],ofilt[8]);
+					lppitch = (int)(v->samp_rate / (basef0 + outf0));
+					outf0 = 0;
+					for (m = F0_FILT_ORD - 1; m > 0; m--) ofilt[m] = ofilt[m - 1];
+				}
+			}
+		}
 		w->sample((SAMPLE *)out_buff + max_frame - pitch, pitch);
+		//printf("  j:%d difpos:%d diflen:%d",j,difpos,diflen);
 		difpos += diflen;
-		if (difpos < -pitch) { j--; difpos += pitch; }
-		if (difpos > pitch) { j++; difpos -= pitch; }
+		if (difpos < -pitch) {
+			if (reply == 1) j--; else k--;
+			difpos += pitch;
+		}
+		if (difpos > pitch) {
+			if (reply == 1) j++;
+			else if (k == reply - 1) { j++; k = 1; }
+			else k++;
+			difpos -= pitch;
+		}
+		//printf(" -> j:%d difpos:%d\n",j,difpos);
 	}
 }
diff -rubN epos-2.4/src/tdpsyn.h usr/src/tdpsyn.h
--- epos-2.4/src/tdpsyn.h	Sun Nov  4 21:44:22 2001
+++ usr/src/tdpsyn.h	Tue May  7 21:52:08 2002
@@ -1,9 +1,9 @@
 /*
- *	epos/src/tdpsyn.cc
- * 	(c) 2000-2001 Petr Horak, petr.horak@click.cz
- * 	(c) 2001 Jirka Hanika, geo@cuni.cz
+ *	epos/src/tdpsyn.h
+ * 	(c) 2000-2002 Petr Horak, horak@petr.cz
+ * 	(c) 2001-2002 Jirka Hanika, geo@cuni.cz
  *
- *	tdpsyn version 1.1 (31.10.2001)
+ *	tdpsyn version 2.3 (19.3.2002)
  *
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -23,6 +23,9 @@
 
 #define t_samp short
 
+#define LPC_PROS_ORDER 4
+#define MAX_OFILT_ORDER 9
+
 const double pii = 3.141592653589793;
 
 int hamkoe(int winlen, double *data);
@@ -38,6 +41,14 @@
 	int *diph_len;
 	int difpos;
 	unsigned short *wwin;
+	double lpfilt[LPC_PROS_ORDER];
+	double ofilt[MAX_OFILT_ORDER];
+	int lppitch;
+	int lpestep;
+	int lppstep;
+	unsigned int sigpos;
+	int basef0;
+	int filtf0;
 	
 	file *tdi;
 	
diff -rubN epos-2.4/src/unit.h usr/src/unit.h
--- epos-2.4/src/unit.h	Sun Nov  4 17:42:56 2001
+++ usr/src/unit.h	Tue May  7 21:52:08 2002
@@ -39,6 +39,7 @@
 	friend void epos_catharsis();	  // necessary only #ifdef WANT_DMALLOC
 	friend class r_inside;
 
+    public:
 	unit *next, *prev;                //same layer
 	unit *firstborn, *lastborn;       //layer lower by one
 	unit *father;                     //layer greater by one
@@ -63,7 +64,7 @@
 	void insane(const char *token);   //called exclusively by sanity() in case of a problem
     
 	int f,i,t;
-    public:
+//    public:
 	bool scope;                       //true=don't pass on Next/Prev requests
 		unit(UNIT layer, parser *);
 		unit(UNIT layer, int content); 
diff -rubN epos-2.4/src/waveform.cc usr/src/waveform.cc
--- epos-2.4/src/waveform.cc	Sun Nov  4 12:04:15 2001
+++ usr/src/waveform.cc	Tue May  7 21:52:08 2002
@@ -1,7 +1,7 @@
 /*
  *	epos/src/waveform.cc
- *	(c) 1998-01 geo@cuni.cz
- *	(c) 2001 horak@ure.cas.cz
+ *	(c) 1998-02 geo@cuni.cz
+ *	(c) 2000-02 horak@ure.cas.cz
  *
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -85,6 +85,8 @@
 	if (!out) return 1;
 	if (working == out) return 1;
 	if (working / 2 == out) return 2;
+	if (working / 3 == out) return 3;
+	if (working / 4 == out) return 4;
 	shriek(462, fmt("Currently, you can only get %d Hz and %d Hz output signal with this voice",
 		working, working / 2));
 	return 1;
@@ -483,10 +485,14 @@
 /* The following is a fixed (FIXME: generalize) low-pass band filter, 0 to 4 kHz */
 
 void
-wavefm::band_filter()
+wavefm::band_filter(int ds)
 {
-	const double a[9] = {1,-2.95588833875285,6.05358859038796,-8.21891083745587,8.44331226032319,-6.3984876438294,3.5670260078076,-1.33913357618129,0.282464627918022};
-	const double b[9] = {0.0085475284871725,0.0230290518801368,0.0495486106178739,0.0712620928385417,0.0820025736317015,0.0712620928385417,0.049548610617874,0.0230290518801368,0.00854752848717252};
+	const double a[3][9] = {1,-2.95588833875285,6.05358859038796,-8.21891083745587,8.44331226032319,-6.3984876438294,3.5670260078076,-1.33913357618129,0.282464627918022,
+							1,-5.64288854258764,15.23495961198290,-25.26198227870461,27.94306848298673,-21.03831667925559,10.52011230037758,-3.19916382894058,0.45524725438187,
+							1,-6.42466721653009,18.92807679520927,-33.22220198267817,37.88644682915341,-28.70015825434698,14.09511202954144,-4.10429644762400,0.54321917883107};
+	const double b[3][9] = {0.0085475284871725,0.0230290518801368,0.0495486106178739,0.0712620928385417,0.0820025736317015,0.0712620928385417,0.049548610617874,0.0230290518801368,0.00854752848717252,
+							0.00182487646825,-0.00196817471641,0.00491609616544,-0.00250076958374,0.00529207410096,-0.00250076958374,0.00491609616544,-0.00196817471641,0.00182487646825,
+							0.00101813708883,-0.00274510939089,0.00509342597553,-0.00601560729994,0.00666275143843,-0.00601560729994,0.00509342597553,-0.00274510939089,0.00101813708883};
 	
 	static double filt[9];
 	int i,j;
@@ -496,9 +502,9 @@
 
 	for (i = 0; i < hdr.buffer_idx; i++) {
 		filt[0] = (double)(SIGNED_SAMPLE)buffer[i];
-		for (j=1;j<9;filt[0]=filt[0]-a[j]*filt[j++]);
+		for (j=1;j<9;filt[0]=filt[0]-a[ds-2][j]*filt[j++]);
 		double outsamp = 0;
-		for (j=0;j<9;outsamp=outsamp+b[j]*filt[j++]);
+		for (j=0;j<9;outsamp=outsamp+b[ds-2][j]*filt[j++]);
 //		printf("%d %f        ", buffer[i], (float)outsamp);
 		buffer[i] = (SAMPLE)(SIGNED_SAMPLE)outsamp;
 		for (j=8;j>0;j--) filt[j]=filt[j-1];		//FIXME: speed up
@@ -557,7 +563,12 @@
 	int target_size = this_voice->samp_size >> 3;
 	target_size *= (1 + (channel != CT_MONO));
 	
-	if (downsamp != 1 && cfg->autofilter) band_filter();	//output is downsampled
+//	if (downsamp != 1 && cfg->autofilter) band_filter();	//output is downsampled
+	if (cfg->autofilter) {
+		if (downsamp == 2) band_filter(downsamp);	//output is downsampled
+		if (downsamp == 3) band_filter(downsamp);	//output is downsampled
+		if (downsamp == 4) band_filter(downsamp);	//output is downsampled
+	}
 	
 	if (downsamp == 1 && working_size == target_size && channel == CT_MONO
 						&& !cfg->ulaw) goto finis;
diff -rubN epos-2.4/src/waveform.h usr/src/waveform.h
--- epos-2.4/src/waveform.h	Sun Nov  4 21:38:08 2001
+++ usr/src/waveform.h	Tue May  7 21:52:08 2002
@@ -109,7 +109,7 @@
 	
 	void translate_data(char *new_buff);	/* recode data from buffer to new_buff */
 	void translate();	/* downsample, stereophonize, eightbitize or ulawize */
-	void band_filter();	/* low band filter applied if downsampling */
+	void band_filter(int ds);	/* low band filter applied if downsampling */
 	bool translated;
 	int downsamp;
 	
