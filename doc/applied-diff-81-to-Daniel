diff -rub ep2-4-81/cfg/cfg/default.ini ep2-4-81-dan/cfg/cfg/default.ini
--- ep2-4-81/cfg/cfg/default.ini	Mon Sep 23 15:43:48 2002
+++ ep2-4-81-dan/cfg/cfg/default.ini	Mon May 12 16:42:03 2003
@@ -68,6 +68,9 @@
 show_raw_segs	false"
 local_sound_device	"""
 immed_segments	false"
+pros_factor	1000"
+label_f0	false"
+dumpfilename	"unitdumpfile.txt""
 autofilter	true"
 wave_header	true"
 ulaw		false"
diff -rub ep2-4-81/cfg/cfg/fixed.ini ep2-4-81-dan/cfg/cfg/fixed.ini
--- ep2-4-81/cfg/cfg/fixed.ini	Wed Jan 30 17:47:04 2002
+++ ep2-4-81-dan/cfg/cfg/fixed.ini	Tue Apr 22 17:49:35 2003
@@ -21,7 +21,7 @@
 readfs		off
 writefs		off
 
-languages	czech:slovak:
+languages	german:czech:slovak:
 # languages	czech:slovak:german:ipcz
 
 #	Levels of linguistic description
@@ -74,7 +74,8 @@
 pros_eff_multiply_f	yes
 pros_eff_multiply_i	yes
 pros_eff_multiply_t	yes
-
+pros_factor 	1000
+label_f0	no
 
 #	Debugging options
 
diff -rub ep2-4-81/cfg/lng/czech/czech.ini ep2-4-81-dan/cfg/lng/czech/czech.ini
--- ep2-4-81/cfg/lng/czech/czech.ini	Mon Sep 23 14:49:17 2002
+++ ep2-4-81-dan/cfg/lng/czech/czech.ini	Mon May 12 16:46:45 2003
@@ -11,8 +11,7 @@
 input_file  "text.txt"
 rules_file  "czech.rul"
 
-voices		theimer:r-machac:r-violka:r-kubec:r-vichov:
-#voices		machac:machac_lpp:violka:violka_lpp:theimer:machac8:violka16:violka8:vichova:kubec-f:kubec-vq:kubec:
+voices		jiri:machac_bang:machac_bang_smooth:machac_lpc_bang:machac_lpc_bang_phone:machac_lpp:machac_bang8:machac_lpc_bang8:machac_lpc_bang_phone8:machac_lpp8:theimer:machac:violka:machac:violka:machac8:violka16:violka8:r-kubec:r-vichov:vichova:kubec-f:kubec-f8:kadlec:kubec-vq:kubec:
 
 fallback_voice	"theimer"
 permanent_fallbacks   on
diff -rub ep2-4-81/cfg/lng/czech/czech.rul ep2-4-81-dan/cfg/lng/czech/czech.rul
--- ep2-4-81/cfg/lng/czech/czech.rul	Wed Apr 16 22:41:45 2003
+++ ep2-4-81-dan/cfg/lng/czech/czech.rul	Fri Mar  7 14:31:02 2003
@@ -57,11 +57,30 @@
 {
 	if   lpcprosody
 	{
+		if use_bang_nnet
+		{
+			if use_nnet_phone 
+			{
+				@include "bang_lpc_pros_phone.rul"
+			}
+			if !use_nnet_phone
+			{
+				@include "bang_lpc_pros.rul"
+			}
+		}
+		if !use_bang_nnet
+		{
 		@include "lpcpros.rul"
-		#@include "prosody.rul"
+		}
 	}
 	if   !lpcprosody
 	{
+		if use_bang_nnet
+		{
+			@include "bang_pros.rul"
+		}
+		if !use_bang_nnet
+		{
 		if   naive_prosody
 		{
 			@include "naive.rul"
@@ -71,6 +90,7 @@
 			@include "prosody.rul"
 		}
 	}
+	}
 }
 
 if	tsr_tool
@@ -125,7 +145,8 @@
 
 if	tsr_tool
 {
-#	debug tsrtool text
+	debug dumpunit text
+#	debug elem phone
 }
 
 #smooth   f/70\30     word segment
Only in ep2-4-81-dan/cfg/lng/czech: neurallog.txt
Only in ep2-4-81-dan/cfg/lng/czech: nnet
Only in ep2-4-81-dan/cfg/lng/czech: prosody.neu
Only in ep2-4-81-dan/cfg/lng/czech: prosody.neuronka
Only in ep2-4-81-dan/cfg/lng/czech: prosody.palkova
Only in ep2-4-81-dan/cfg/lng/czech: prosody_bang.neu
Only in ep2-4-81-dan/cfg/lng/czech: prosody_lpc_bang.neu
Only in ep2-4-81-dan/cfg/lng/czech: prosody_lpc_bang_phone.neu
Only in ep2-4-81-dan/cfg/lng/czech: prosody_oznam.neu
Only in ep2-4-81-dan/cfg/lng/czech: prosody_oznam.rul
Only in ep2-4-81-dan/cfg/lng/german: 010802_hadi-bomp.tgz
diff -rub ep2-4-81/cfg/lng/german/german.ini ep2-4-81-dan/cfg/lng/german/german.ini
--- ep2-4-81/cfg/lng/german/german.ini	Sun Nov  4 12:43:27 2001
+++ ep2-4-81-dan/cfg/lng/german/german.ini	Mon Apr 28 11:44:13 2003
@@ -9,6 +9,8 @@
 
 #	Pou¾ívané adresáøe a soubory
 
+voices		joerg:
+
 input_file  "text.txt"
 rules_file  "german.rul"
 
@@ -18,9 +20,9 @@
 ;invent_dir	"inv"
 
 #	Pár zatím bezvýznamných konstant
-init_t		 80 
+init_f			 95
+init_t			 140
 init_i		100
-init_f		100
 
 
 #	Pøípustná písmenka
diff -rub ep2-4-81/cfg/lng/german/german.rul ep2-4-81-dan/cfg/lng/german/german.rul
--- ep2-4-81/cfg/lng/german/german.rul	Wed Aug  1 14:54:40 2001
+++ ep2-4-81-dan/cfg/lng/german/german.rul	Thu May  8 20:05:22 2003
@@ -1,56 +1,112 @@
-#
-#	provisorische Regeln, Jirka Hanika <geo@ff.cuni.cz>
-#
-#
-
-$voiced    = bdgvzZh¾
-$voiceless = ptkfscx¹
-$fric      = sz¹¾fvhxß
-$afric     = cZè®
-$stop      = ptkbdg
-$nasal     = mnN
-$sonant    = jlr$nasal
-$short     = aeiouäöüy
-$long      = áéíóúäöüý
-#$diphtong  = OAE
-$vowel     = $short$long    #...$diphtong
-$consonant=$voiced$voiceless$sonant
-$everywhere= !_!
-$sonority  = 0'<$fric$afric${stop}$nasal<lrj<$vowel
-
- regress   0>s(x_!)
- regress   u0>0v(q_!)
- regress   0>v(q_!)                ; Rozlo¾ení x,q na ks, kv
- regress   xq>k($everywhere)
- regress   h>x(c_!)                ; Spøe¾ka ch > x
- progress  c>0(!_x)
- progress  s>¹(!_x)
- regress   x>0(¹_!)
- regress   i>í(!_e)
- regress   e>0(í_!)
-
- regress   s>¹(0$consonant_$voiceless)
- regress   z>c($everywhere)
- regress   s>ß(s_!)
- regress   s>0(!_ß)
- regress   sß>zs($everywhere)
- regress   e>a(!_i)
- regress   i>j(a_!)
- regress   v>f($everywhere)
- regress   w>v($everywhere)
-
-
- regress   $voiced>${voiceless}(!_$voiceless&0')       	; Asimilace znìlosti
- regress   $voiceless>$voiced(!_$voiced!v)
-
-
- subst     ../czech/syll.dic		; Rozsadit vokály
-
- syll      $sonority	syll	; Rozklad_na_slabiky
-
- regress   0>q(!_0)
- regress   $short>$long(!_0h)   syll
- regress   q>0(!_0)
- regress   h>0($long_!)		syll
+$big	= ABCDEFGHIJKLMNOPQRSTUVWXYZÄÖÜ
+$little = abcdefghijklmnopqrstuvwxyzäöü
 
- diphones  ../czech/kadlec.dph		colon
+# substitute these if they were in input, because they are used
+# in the dictionary
+regress \_>\ (!_!) word phone
+regress \+>\ (!_!) word phone
+regress \=>\ (!_!) word phone 
+regress \'>\ (!_!) word phone
+regress \%>\ (!_!) word phone
+
+subst     hadi-bomp/bomp_epos_exact.dic  word phone
+
+# some magic for words whose substitution did not work
+
+# when the input isonly CAPS then say the word letter-by-letter
+near *$big word phone
+{
+	# regress	$little>$big(!_!)	phone phone
+	regress 0>+(!0_!)		phone phone
+	syll 0<+	word phone
+	regress	\+>0(!_!) word phone
+	subst     hadi-bomp/bomp_suppl.dic syll phone
+	syll 0<\+	word phone
+
+}
+
+# try the upper-case version
+near *!\+ word phone
+{
+	regress $little>$big(0_!) word phone
+	subst     hadi-bomp/bomp_epos_exact.dic  word phone
+	syll 0<\+	word phone
+}
+
+#try the lower-case version
+near *!\+ word phone
+{
+	regress $big>$little(0_!) word phone
+	subst     hadi-bomp/bomp_epos_exact.dic  word phone
+	syll 0<\+	word phone
+}
+
+
+
+#convert all to lower case, try the rule which searches for word-parts
+near *!\+ word phone
+{
+	regress $big>$little(!_!) word phone
+	mysubst     hadi-bomp/bomp_epos_all.dic  word phone
+
+	regex /XAXA/XA/ word 
+
+	# throw away marks at beginning and end of word
+	regress X>0(0_!)	word phone
+	regress X>0(!_0)	word phone
+	regress A>0(0_!)	word phone
+	regress A>0(!_0)	word phone
+	# regress X>0(0_!)	word phone
+	# regress X>0(!_0)	word phone
+
+	# but we need one at the end
+	regress 0>X(!_0)	word phone
+	regress 0>A(!_0)	word phone
+
+	# raise X:X		word phone
+	syll 0<X		word phone
+	regress X>0(!_!)	syll phone
+	regress A>0(!_!)	syll phone
+	# regress X>0(!_!)	syll phone
+
+	debug dumpunit word
+
+	near *!\+ syll phone
+	{
+		debug dumpunit syll
+		subst hadi-bomp/bomp_epos_syll.dic	syll phone
+	}
+
+	# I want to delete every glottal stop that's not at the beginning of the word... shall I?
+	regress Q>X(0_!)	word phone
+	regress Q>0(!_!) 	word phone
+	regress X>Q(0_!)	word phone
+
+}
+
+
+# debug dumpunit text
+
+# split word into syllables
+regress	\+>0(!_!) word phone
+
+debug dumpunit text
+
+# raise F0 on main stress syllable
+near \' syll phone
+{
+	contour	f/+15*	syll phone
+}
+regress \'>0(!_!) word phone
+
+
+# lower F0 on second stress syllable
+near \= syll phone
+{
+	contour	f/-15*	syll phone
+}
+regress \=>0(!_!) word phone 
+
+
+
+segments  joerg.dph		colon
Only in ep2-4-81-dan/cfg/lng/german: german_good.ini
Only in ep2-4-81-dan/cfg/lng/german: german_old.rul
Only in ep2-4-81-dan/cfg/lng/german: hadi-bomp
Only in ep2-4-81-dan/cfg/lng/german: joerg.dph
Only in ep2-4-81-dan/cfg/lng/german: letters.dic
Only in ep2-4-81-dan/cfg/lng/slovak: #%=2Aediff-merge=3C3=3E=2A#
diff -rub ep2-4-81/cfg/lng/slovak/slovak.ini ep2-4-81-dan/cfg/lng/slovak/slovak.ini
--- ep2-4-81/cfg/lng/slovak/slovak.ini	Tue Aug 20 09:43:05 2002
+++ ep2-4-81-dan/cfg/lng/slovak/slovak.ini	Mon Nov  5 07:08:44 2001
@@ -4,7 +4,7 @@
 
 rules_file	slovak.rul
 
-voices		igor:
+voices		igor:petriska:kadlec
 
 fallback_voice	petriska
 permanent_fallbacks on
Only in ep2-4-81/cfg: root
Only in ep2-4-81-dan/cfg/voice/czech: jiri.ini
Only in ep2-4-81-dan/cfg/voice/czech: kubec-f8.ini
Only in ep2-4-81-dan/cfg/voice/czech: machac_bang.ini
Only in ep2-4-81-dan/cfg/voice/czech: machac_bang8.ini
Only in ep2-4-81-dan/cfg/voice/czech: machac_bang_smooth.ini
Only in ep2-4-81-dan/cfg/voice/czech: machac_lpc_bang.ini
Only in ep2-4-81-dan/cfg/voice/czech: machac_lpc_bang8.ini
Only in ep2-4-81-dan/cfg/voice/czech: machac_lpc_bang_phone.ini
Only in ep2-4-81-dan/cfg/voice/czech: machac_lpc_bang_phone8.ini
Only in ep2-4-81-dan/cfg/voice/czech: machac_lpp8.ini
Only in ep2-4-81-dan/cfg/voice: german
Only in ep2-4-81: doc
Only in ep2-4-81-dan/src: #unit.h#
Only in ep2-4-81/src: Makefile
diff -rub ep2-4-81/src/Makefile.in ep2-4-81-dan/src/Makefile.in
--- ep2-4-81/src/Makefile.in	Sun Aug 18 14:50:38 2002
+++ ep2-4-81-dan/src/Makefile.in	Thu Jan  9 16:47:33 2003
@@ -21,7 +21,7 @@
 
 #add -pg for profiling, -ggdb for gdb debugging
 
-CFLAGS=@CFLAGS@
+CFLAGS=@CXXFLAGS@ -w -DEPOS
 FLAGS=$(DMALLOC_STATUS) $(HOMEMADE_STRDUP) $(CFLAGS)
 LINKFLAGS=
 
@@ -41,9 +41,9 @@
 
 HEADERS=common.h defaults.h unit.h parser.h rule.h text.h encoding.h interf.h function.h options.h hash.h synth.h voice.h exc.h
 MOREHEADERS=waveform.h ktdsyn.h ptdsyn.h lpcsyn.h tdpsyn.h tcpsyn.h slab.h rx.h client.h agent.h 
-SOURCES=parser.cc unit.cc marker.cc rule.cc block.cc text.cc encoding.cc interf.cc function.cc options.cc exc.cc hash.cc hashd.cc hashtmpl.cc synth.cc waveform.cc voice.cc say.cc options.lst nnet.cc monolith.cc daemon.cc agent.cc ttscp.cc client.cc qnxipc.cc ktdsyn.cc ptdsyn.cc lpcsyn.cc tdpsyn.cc tcpsyn.cc rx.c gauge.cc
+SOURCES=parser.cc unit.cc marker.cc rule.cc block.cc text.cc encoding.cc interf.cc function.cc options.cc exc.cc hash.cc hashd.cc hashtmpl.cc synth.cc waveform.cc voice.cc say.cc options.lst nnet.cc monolith.cc daemon.cc agent.cc ttscp.cc client.cc qnxipc.cc ktdsyn.cc ptdsyn.cc lpcsyn.cc tdpsyn.cc tcpsyn.cc rx.c gauge.cc nnet/stream/bang_fstream.cpp nnet/stream/bang_iostream.cpp nnet/stream/bang_istream.cpp nnet/stream/bang_ostream.cpp nnet/enumstring.cpp nnet/map.cpp nnet/matrix.cpp nnet/perceptron.cpp nnet/percinit.cpp nnet/percstruct.cpp nnet/set.cpp nnet/string.cpp nnet/traindata.cpp nnet/utils.cpp nnet/xml.cpp nnet/xml.y.tab.cpp nnet/xmltempl.cpp nnet/xmlutils.cpp neural.cc neural.tab.cc
 DOSSOURCES=epos.cpp config.dos README.dos
-MODULES=parser.o unit.o rule.o text.o encoding.o interf.o function.o options.o synth.o ktdsyn.o ptdsyn.o lpcsyn.o tdpsyn.o tcpsyn.o voice.o waveform.o
+MODULES=parser.o unit.o rule.o text.o encoding.o interf.o function.o options.o synth.o ktdsyn.o ptdsyn.o lpcsyn.o tdpsyn.o tcpsyn.o voice.o waveform.o bang_fstream.o bang_iostream.o bang_istream.o bang_ostream.o enumstring.o map.o matrix.o perceptron.o percinit.o percstruct.o set.o string.o traindata.o utils.o xml.o xmltempl.o xmlutils.o neural.o neural.tab.o xml.y.tab.o
 TARGETS=epos say vrfy gauge
 DOSES=  dos1250 dos1252 dospc2 dosil1 dosil2 doskam doskoi8 dosascii dosmac dosvga
 
@@ -252,6 +252,45 @@
 tcpsyn.o: tcpsyn.h tcpsyn.cc client.h waveform.h interf.h options.lst $(MAKEFILE)
 	$(CC) $(FLAGS) -c -o $@ tcpsyn.cc
 
-
+bang_fstream.o:
+	$(CC) $(FLAGS) -c -o $@ nnet/stream/bang_fstream.cpp
+bang_iostream.o:
+	$(CC) $(FLAGS) -c -o $@ nnet/stream/bang_iostream.cpp
+bang_istream.o:
+	$(CC) $(FLAGS) -c -o $@ nnet/stream/bang_istream.cpp
+bang_ostream.o:
+	$(CC) $(FLAGS) -c -o $@ nnet/stream/bang_ostream.cpp
+enumstring.o:
+	$(CC) $(FLAGS) -c -o $@ nnet/enumstring.cpp
+map.o:
+	$(CC) $(FLAGS) -c -o $@ nnet/map.cpp
+matrix.o:
+	$(CC) $(FLAGS) -c -o $@ nnet/matrix.cpp
+perceptron.o:
+	$(CC) $(FLAGS) -c -o $@ nnet/perceptron.cpp
+percinit.o:
+	$(CC) $(FLAGS) -c -o $@ nnet/percinit.cpp
+percstruct.o:
+	$(CC) $(FLAGS) -c -o $@ nnet/percstruct.cpp
+set.o:
+	$(CC) $(FLAGS) -c -o $@ nnet/set.cpp
+string.o:
+	$(CC) $(FLAGS) -c -o $@ nnet/string.cpp
+traindata.o:
+	$(CC) $(FLAGS) -c -o $@ nnet/traindata.cpp
+utils.o:
+	$(CC) $(FLAGS) -c -o $@ nnet/utils.cpp
+xml.o:
+	$(CC) $(FLAGS) -c -o $@ nnet/xml.cpp
+xml.y.tab.o:
+	$(CC) $(FLAGS) -c -o $@ nnet/xml.y.tab.cpp
+xmltempl.o:
+	$(CC) $(FLAGS) -c -o $@ nnet/xmltempl.cpp
+xmlutils.o:
+	$(CC) $(FLAGS) -c -o $@ nnet/xmlutils.cpp
+neural.o:
+	$(CC) $(FLAGS) -c -o $@ neural.cc
+neural.tab.o:
+	$(CC) $(FLAGS) -c -o $@ neural.tab.cc
 qnxipc.o: qnxipc.cc $(HEADERS) agent.h client.h client.cc
 	$(CC) $(FLAGS) -c -o $@ qnxipc.cc -DSTANDALONE_COMPILE 
diff -rub ep2-4-81/src/agent.h ep2-4-81-dan/src/agent.h
--- ep2-4-81/src/agent.h	Sun Aug 18 12:48:36 2002
+++ ep2-4-81-dan/src/agent.h	Mon Jan  6 12:52:37 2003
@@ -87,7 +87,7 @@
 
 class agent
 {
-	friend stream;
+	friend class stream;
 	friend void server();
 
 	virtual void run() = 0;	/* run until out of input			*/
Only in ep2-4-81-dan/src: autom4te-2.53.cache
diff -rub ep2-4-81/src/block.cc ep2-4-81-dan/src/block.cc
--- ep2-4-81/src/block.cc	Wed Nov  7 09:27:32 2001
+++ ep2-4-81-dan/src/block.cc	Wed Apr 30 13:46:00 2003
@@ -477,6 +477,7 @@
 
 	case OP_DIPH:    result = new r_seg(word[param]); break;
 	case OP_SUBST:   result = new r_subst(word[param]); break;
+	case OP_MYSUBST: result = new r_mysubst(word[param]); break;
 #ifdef WANT_REGEX
 	case OP_REGEX:   result = new r_regex(word[param]); break;
 #else
@@ -503,6 +504,8 @@
 	case OP_SWITCH:  result = new r_switch(file, vars); break;
 	case OP_SWEND:	 return END_OF_SWITCH;
 	case OP_NOTHING: result = new r_nothing(); break;
+	case OP_NEURAL:  result = new r_neural(word[param], vars); break;
+
 	default:  diatax("Unknown rule type"); goto next_line;  // to fool the compiler
 
 	}
diff -rub ep2-4-81/src/common.h ep2-4-81-dan/src/common.h
--- ep2-4-81/src/common.h	Sun May 11 21:44:06 2003
+++ ep2-4-81-dan/src/common.h	Tue May 13 22:22:20 2003
@@ -80,7 +80,7 @@
 
 
 enum SYMTABLE {ST_ROOT, ST_RAW, ST_EMPTY};
-enum SUBST_METHOD {M_EXACT=0, M_END=1, M_BEGIN=2, M_BEGIN_OR_END=3, M_SUBSTR=4, M_PROPER=7, M_LEFT=8, M_RIGHT=16, M_ONCE=32, M_NEGATED=64};
+enum SUBST_METHOD {M_EXACT=0, M_END=1, M_BEGIN=2, M_BEGIN_OR_END=3, M_SUBSTR=4, M_PROPER=7, M_LEFT=8, M_RIGHT=16, M_ONCE=32, M_NEGATED=64, M_MYSUBST=160};
 enum REPARENT {M_DELETE, M_RIGHTWARDS, M_LEFTWARDS};
 enum FIT_IDX {Q_FREQ, Q_INTENS, Q_TIME};
 #define FITstr	"f:i:t:"
@@ -100,7 +100,7 @@
 extern const bool is_monolith;
 
 struct file;
-struct option;
+struct epos_option;
 class  unit;
 
 class stream;
Only in ep2-4-81-dan/src: config.h
Only in ep2-4-81-dan/src: config.log
Only in ep2-4-81/src: configure
diff -rub ep2-4-81/src/daemon.cc ep2-4-81-dan/src/daemon.cc
--- ep2-4-81/src/daemon.cc	Sun Aug 18 14:24:50 2002
+++ ep2-4-81-dan/src/daemon.cc	Tue Mar 18 11:17:15 2003
@@ -232,7 +232,13 @@
 static void detach()
 {
 	int i;
+#ifndef WIN32
+#ifdef TIOCNOTTY
         UNIX (ioctl(0, TIOCNOTTY);)          //Release the control terminal
+#else
+	  setpgrp();
+#endif
+#endif
 	if (!cfg->daemon_log || !*cfg->daemon_log)
 		return;
 	for (i=0; i<3; i++) close(i);
Only in ep2-4-81-dan/src: debuglog
Only in ep2-4-81-dan/src: delme.cc
diff -rub ep2-4-81/src/encoding.cc ep2-4-81-dan/src/encoding.cc
--- ep2-4-81/src/encoding.cc	Wed May  8 00:48:08 2002
+++ ep2-4-81-dan/src/encoding.cc	Tue Jan 14 12:42:00 2003
@@ -125,6 +125,7 @@
 
 void encode_string(unsigned char *s, int cs, bool alloc)
 {
+
 	do {
 		int t = encoders[cs][*s];
 		if (t == UNDEFINED && *s) {
@@ -132,7 +133,7 @@
 				wchar_t u = charsets[cs][*s];
 				if (u == UNDEFINED) u = non_unicode_alloc_code(*s);
 				if (u == UNDEFINED)
-					shriek(418, fmt(cs ? "Illegal character %c" : "Unspecified charset for character %c", *s));  // FIXME - filename
+					shriek(418, fmt(cs ? "Illegal character '%c' in int '%d'" : "Unspecified charset for character %c in int %d", *s, (unsigned int) *s));  // FIXME - filename
 				alloc_code(u, *s, cs);
 				continue;
 			} else if (cfg->relax_input) {
Only in ep2-4-81-dan/src: globals.h
Only in ep2-4-81-dan/src: hash.cpp
Only in ep2-4-81-dan/src: install.cc
Only in ep2-4-81-dan/src: neural.cc
Only in ep2-4-81-dan/src: neural.cpp.h
Only in ep2-4-81-dan/src: neural.h
Only in ep2-4-81-dan/src: neural.old.cc
Only in ep2-4-81-dan/src: neural.old.h
Only in ep2-4-81-dan/src: neural.tab.cc
Only in ep2-4-81-dan/src: neural.tab.cpp.h
Only in ep2-4-81-dan/src: neural.y
Only in ep2-4-81-dan/src: nnet
diff -rub ep2-4-81/src/options.cc ep2-4-81-dan/src/options.cc
--- ep2-4-81/src/options.cc	Mon Mar 25 00:34:02 2002
+++ ep2-4-81-dan/src/options.cc	Tue Mar  4 13:12:11 2003
@@ -100,9 +100,9 @@
 	cfg->cow++;
 }
 
-static inline void cow_free(cowabilium *p, option *opts, void *extra)
+static inline void cow_free(cowabilium *p, epos_option *opts, void *extra)
 {
-	for (option *o = opts; o->optname; o++) {
+	for (epos_option *o = opts; o->optname; o++) {
 		if (o->opttype != O_STRING) continue;
 		if (*(char **)((char *)p->parent + o->offset)
 		 != *(char **)((char *)p + o->offset)) {
@@ -121,7 +121,7 @@
 	if (extra) free(extra);
 }
 
-extern option optlist[];
+extern epos_option optlist[];
 
 void cow_unclaim(configuration *that_cfg)
 {
@@ -161,7 +161,7 @@
 configuration *cfg = &master_cfg;
 
 #define CONFIG_DESCRIBE
-option optlist[]={
+epos_option optlist[]={
         #include "options.lst"
 
 	{"C:language" + 2, O_LANG, OS_CFG, A_PUBLIC, A_PUBLIC, false, false, 0},
@@ -177,7 +177,7 @@
 #undef EO
 #undef TWENTY_EXTRA_OPTIONS
 
-hash_table<char, option> *option_set = NULL;
+hash_table<char, epos_option> *option_set = NULL;
 
 void configuration::shutdown()
 {
@@ -199,7 +199,7 @@
  *	respectively), eating up minimum memory space only.
  */
 
-inline void put_into_option_set(option *o)
+inline void put_into_option_set(epos_option *o)
 {
 	if (*o->optname) {
 		option_set->add(o->optname, o);
@@ -209,11 +209,11 @@
 
 void make_option_set()
 {
-	option *o;
+	epos_option *o;
 
 	if (option_set) return;
 
-	option_set = new hash_table<char, option>(300);
+	option_set = new hash_table<char, epos_option>(300);
 	option_set->dupkey = option_set->dupdata = 0;
 
 	for (o = optlist; o->optname; o++) 	put_into_option_set(o);
@@ -226,7 +226,7 @@
 
 void restrict_options()
 {
-	option *o;
+	epos_option *o;
 
 	text *t = new text(cfg->restr_file, cfg->ini_dir, "", NULL, true);
 	if (!t->exists()) {
@@ -259,11 +259,11 @@
 	delete t;
 }
 
-option *alloc_option(option *optlist, OPT_STRUCT os)
+epos_option *alloc_option(epos_option *optlist, OPT_STRUCT os)
 {
 	DEBUG(1,10,fprintf(STDDBG, "Allocating an extra option, level %d\n", os);)
 
-	option *o;
+	epos_option *o;
 	for (o = optlist; ; o++) {
 		if (o->offset == -1) return o;
 		if (o->offset == -2) shriek(864, "No more options to allocate, add extra options");
@@ -273,14 +273,14 @@
 
 #define MAX_TOTAL_OPTION_NAME 64
 
-void alloc_level_options(option *optlist, OPT_STRUCT os, cowabilium *base, int levnum, const char *levname)
+void alloc_level_options(epos_option *optlist, OPT_STRUCT os, cowabilium *base, int levnum, const char *levname)
 {
 	char b[MAX_TOTAL_OPTION_NAME];
 
-	option *o;
+	epos_option *o;
 	for (o=optlist; o->optname; o++) {
 		if (o->per_level) {
-			option *p = alloc_option(optlist, os);
+			epos_option *p = alloc_option(optlist, os);
 			b[0] = "CLV"[os];
 			b[1] = ':';
 			strcpy(b+2, o->optname);
@@ -376,7 +376,7 @@
  *		options it doesn't handle specially.
  */
 
-const char *invoke_set_action(option *o, const char *value)
+const char *invoke_set_action(epos_option *o, const char *value)
 {
 	const char *on = strchr(o->optname, ':') ? strchr(o->optname, ':') + 1 : o->optname;
 	if (!strcmp(on, "init_f")) {
@@ -402,9 +402,9 @@
 	return value;
 }
 
-option *option_struct(const char *name, hash_table<char, option> *softopts)
+epos_option *option_struct(const char *name, hash_table<char, epos_option> *softopts)
 {
-	option *o;
+	epos_option *o;
 
 	if (!option_set) shriek(862, "no config_init()");
 	if (!name || !*name) return NULL;
@@ -433,7 +433,7 @@
 	*netto = 0;
 }
 
-template<class T> inline void set_enum_option(option *o, const char *val, const char *list, char *locus)
+template<class T> inline void set_enum_option(epos_option *o, const char *val, const char *list, char *locus)
 {
 	parse_cfg_str(const_cast<char *>(val));
 	T tmp = (T)str2enum(val, list, U_ILL);
@@ -442,7 +442,7 @@
 	*(T *)locus = tmp;
 }
 
-bool set_option(option *o, const char *val, void *base)
+bool set_option(epos_option *o, const char *val, void *base)
 {
 	int tmp;
 	if (!o) return false;
@@ -541,7 +541,7 @@
 #define  VOICES_OFFSET  ((int)&((lang *)NULL)->voices)
 #define  VOICES_LENGTH  (this_lang->n_voices * sizeof(void *))
 
-bool set_option(option *o, const char *value)
+bool set_option(epos_option *o, const char *value)
 {
 	if (!o) return false;
 	switch(o->structype) {
@@ -572,7 +572,7 @@
 
 static inline void set_option_or_die(char *name, const char *value)
 {
-	option *o = option_struct(name, NULL);
+	epos_option *o = option_struct(name, NULL);
 	if (!o) shriek(814, fmt("Unknown option %s", name));
 	if (!cfg->langs && (o->structype != OS_CFG || o->opttype == O_LANG))
 		return;
@@ -585,7 +585,7 @@
  *	For the following one, make sure that base is the correct type
  */
 
-static inline bool set_option(char *name, char *value, void *base, hash_table<char, option> *softopts)
+static inline bool set_option(char *name, char *value, void *base, hash_table<char, epos_option> *softopts)
 {
 	return set_option(option_struct(name, softopts), value, base);
 }
@@ -614,7 +614,7 @@
 	return false;
 }
 
-const char *format_option(option *o, void *base)
+const char *format_option(epos_option *o, void *base)
 {
 	char *locus = (char *)base + o->offset;
 	switch(o->opttype) {
@@ -648,7 +648,7 @@
 	return NULL; /* unreachable */
 }
 
-const char *format_option(option *o)
+const char *format_option(epos_option *o)
 {
 	switch(o->structype) {
 		case OS_CFG:   return format_option(o, cfg);
@@ -661,7 +661,7 @@
 
 const char *format_option(const char *name)
 {
-	option *o = option_struct(name, this_lang->soft_options);
+	epos_option *o = option_struct(name, this_lang->soft_options);
 	if (!o) {
 		shriek(442, fmt("Nonexistent option %s", name));
 		return NULL; /* unreachable */
@@ -778,7 +778,7 @@
 			if (value[i]) i++;
 			value[i] = 0;		// clumsy: strip off trailing whitespace
 		}
-		if (!set_option(line - 2, value, whither, parent_lang ? parent_lang->soft_options : (hash_table<char, option> *)NULL))
+		if (!set_option(line - 2, value, whither, parent_lang ? parent_lang->soft_options : (hash_table<char, epos_option> *)NULL))
 			shriek(812, fmt("Bad option %s in %s:%d", line, t->current_file, t->current_line));
 	}
 	free(line - 2);
diff -rub ep2-4-81/src/options.h ep2-4-81-dan/src/options.h
--- ep2-4-81/src/options.h	Sun Nov  4 15:40:28 2001
+++ ep2-4-81-dan/src/options.h	Tue Mar  4 13:12:44 2003
@@ -66,7 +66,7 @@
 
 void cow_configuration(configuration **);
 
-struct option
+struct epos_option
 {
 	const char *optname;
   	OPT_TYPE opttype	BIT_FIELD(5);
@@ -84,16 +84,16 @@
 
 // void process_options(hash *tab, option *list, void *base);
 // char *get_named_cfg(const char *option_name);
-option *option_struct(const char *name, hash_table<char, option> *softopts);
+epos_option *option_struct(const char *name, hash_table<char, epos_option> *softopts);
 
 /* For the following two functions, the value MAY get changed by set_option()
    (in-place), if o->opttype is O_STRING or O_CHAR and value contains
    backslashes or double quotes  		*/
-bool set_option(option *o, const char *value);			// the const qualifier IS A LIE
-bool set_option(option *o, const char *value, void *whither);	// the const qualifier IS A LIE
+bool set_option(epos_option *o, const char *value);			// the const qualifier IS A LIE
+bool set_option(epos_option *o, const char *value, void *whither);	// the const qualifier IS A LIE
 
 
-const char *format_option(option *name);	// may return scratch etc.
+const char *format_option(epos_option *name);	// may return scratch etc.
 const char *format_option(const char *name);  // ditto
 
 bool lang_switch(const char *name);
diff -rub ep2-4-81/src/options.lst ep2-4-81-dan/src/options.lst
--- ep2-4-81/src/options.lst	Fri Sep 20 15:27:02 2002
+++ ep2-4-81-dan/src/options.lst	Mon May 12 15:40:44 2003
@@ -446,8 +446,16 @@
 	// positive value specifies the required output rate (samp_rate divided by an integer)
 //VOICE_OPTION (f0_model, f0_model, "f0_modelling", STR, "classic")	// F0 contour modelling (classic, lpc, fujisaki)
 VOICE_OPTION (lpcprosody, lpcprosody, "lpcprosody", BOOL, false)	// F0 contour modelling using a linear prediction
+VOICE_OPTION (use_bang_nnet, use_bang_nnet, "use_bang_nnet", BOOL, false)	// F0 contour modelling using a linear prediction
+VOICE_OPTION (use_nnet_phone, use_nnet_phone, "use_nnet_phone", BOOL, false)	// F0 contour with lpc but on the phone level
+VOICE_OPTION (use_f0_smoothing, use_f0_smoothing, "use_f0_smoothing", BOOL, false) // generated F0 shall be smoothed via filter after each pitchpuls
 VOICE_OPTION (additive_cont, additive_cont, "additive_cont", BOOL, false)  // rule "contour" additive mode
 
+OPTION (pros_factor, "pros_factor", INT, 1000)				// this controls how strong prosody is applied
+OPTION (label_f0, "label_f0", BOOL, false)
+
+OPTION (dumpfilename, "dumpfilename", STR, "unitdumpfile.txt")  // name of file to dump if debug rule dumpunit executed
+
 OPTION (autofilter, "autofilter", BOOL, true)	// When downsampling, band filter as necessary
 
 OPTION (wav_hdr, "wave_header",	  BOOL, true)   // Should .wav output contain .wav file header?
diff -rub ep2-4-81/src/rule.cc ep2-4-81-dan/src/rule.cc
--- ep2-4-81/src/rule.cc	Sun May 11 22:24:17 2003
+++ ep2-4-81-dan/src/rule.cc	Tue May 13 22:37:36 2003
@@ -24,8 +24,8 @@
 
 #define DIPH_BUFF_SIZE  1000 //unimportant
 
-#define OPCODEstr "subst:regex:postp:prep:segments:prosody:contour:progress:regress:insert:syll:smooth:raise:debug:if:inside:near:with:{:}:[:]:<:>:nothing:error:"
-enum OPCODE {OP_SUBST, OP_REGEX, OP_POSTP, OP_PREP, OP_DIPH, OP_PROSODY, OP_CONTOUR, OP_PROGRESS, OP_REGRESS, 
+#define OPCODEstr "neuralnet:subst:mysubst:regex:postp:prep:segments:prosody:contour:progress:regress:insert:syll:smooth:raise:debug:if:inside:near:with:{:}:[:]:<:>:nothing:error:"
+enum OPCODE {OP_NEURAL, OP_SUBST, OP_MYSUBST, OP_REGEX, OP_POSTP, OP_PREP, OP_DIPH, OP_PROSODY, OP_CONTOUR, OP_PROGRESS, OP_REGRESS, 
 	OP_INSERT, OP_SYLL, OP_SMOOTH, OP_RAISE, OP_DEBUG, OP_IF, OP_INSIDE, OP_NEAR, OP_WITH,
 	OP_BEGIN, OP_END, OP_CHOICE, OP_CHOICEND, OP_SWITCH, OP_SWEND, OP_NOTHING, OP_ERROR};
 		/* OP_BEGIN, OP_END and other OP's without parameters should come last
@@ -331,7 +331,7 @@
 {
 	method = M_LEFT;
 	if (negated) {
-		method = (SUBST_METHOD) (method | M_NEGATED);
+		method = (SUBST_METHOD)(method | M_NEGATED);
 		negated = 1;
 	}
 	allow_id = true;
@@ -343,6 +343,28 @@
 	rule::set_level(scp, trg);
 }
 
+class r_mysubst: public hashing_rule
+{
+   protected:
+	SUBST_METHOD method;
+	virtual OPCODE code() {return OP_SUBST;};
+   public:
+		r_mysubst(char *param);
+	virtual void set_level(UNIT scope, UNIT target);
+	virtual void apply(unit *root);
+};
+
+r_mysubst::r_mysubst(char *param) : hashing_rule(param)
+{
+	method = M_MYSUBST;
+}
+
+void
+r_mysubst::set_level(UNIT scp, UNIT trg)
+{
+	rule::set_level(scp, trg);
+}
+
 /************************************************
  r_subst::apply
  ************************************************/
@@ -363,6 +385,22 @@
 	}
 }
 
+void
+r_mysubst::apply(unit *root)
+{
+	if (!dict) load_hash();
+
+//	if (target == U_PHONE) root->subst(dict, method);
+
+	root->relabel(dict, method, target);
+
+	if (cfg->lowmemory) {
+		DEBUG(2,2,fprintf(STDDBG,"Hash table caching is disabled.\n");) //hashtabscache[rulist[i].param]->debug();
+		delete dict;
+		dict = NULL;
+	}
+}
+
 /************************************************
  r_seg   The following rule class constructs
  	  the segment layer according to segment
@@ -920,6 +958,7 @@
 //	else if(strstr(raw,"rule") && ruleset->current_rule+1 < ruleset->n_rules)
 //		ruleset->rulist[ruleset->current_rule+1]->debug();
 	if(strstr(raw,"pause")) user_pause();
+	if(strstr(raw,"dumpunit")) root->filedump ((char*) cfg->dumpfilename);
 }
 
 /************************************************
@@ -1104,7 +1143,7 @@
 
 r_if::r_if(char *param, text *file, hash *vars) : cond_rule(param, file, vars)
 {
-	option *o = option_struct(raw + (*raw == EXCLAM) , this_lang->soft_options);
+	epos_option *o = option_struct(raw + (*raw == EXCLAM) , this_lang->soft_options);
 	if (!o) shriek(811, fmt("%s Not an option: %s", debug_tag(), raw));
 	if (o->opttype != O_BOOL) shriek(811, fmt("%s Not a truth value option: %s", debug_tag(), raw));
 	if (o->structype != OS_VOICE) shriek(811, fmt("%s Not a voice option: %s", debug_tag(), raw));
@@ -1142,5 +1181,43 @@
 	virtual void apply(unit *) {};
 };
 
+
+/************************************************
+ r_neural  Neuralnet created by Jakub Adamek
+ 	    look at neural.cc, neural.h, unit.cc
+ **	 
+ ************************************************/
+
+#include "neural.h"
+
+class r_neural: public rule
+{
+protected:
+	virtual OPCODE code() {return OP_NEURAL;};
+	CNeuralNet *neuralnet;
+public:
+	r_neural (char *param, hash *vars);
+	virtual ~r_neural ();
+	virtual void apply(unit *root);
+};
+
+void
+r_neural::apply (unit *root)
+{
+	neuralnet->init();
+	root->neural (target, neuralnet);
+}
+
+r_neural::r_neural(char *param, hash *vars) : rule(param)
+{
+	raw = strdup(param);
+	neuralnet = new CNeuralNet (raw, vars);
+}
+
+r_neural::~r_neural ()
+{
+	if (neuralnet) delete neuralnet;
+}
+
 #include "block.cc"
 
Only in ep2-4-81-dan/src: samples
diff -rub ep2-4-81/src/synth.cc ep2-4-81-dan/src/synth.cc
--- ep2-4-81/src/synth.cc	Fri Sep 20 15:19:11 2002
+++ ep2-4-81-dan/src/synth.cc	Tue Mar 18 11:22:29 2003
@@ -24,6 +24,10 @@
 #define SOUND_LABEL_BASE	(1 << SOUND_LABEL_SHIFT)
 #define SOUND_LABEL_SHIFT	10
 
+#ifdef WIN32
+#define snprintf _snprintf
+#endif
+
 synth *setup_synth(voice *v)
 {
 	if (v->syn) shriek(862, "new v->syn - again");
@@ -124,15 +128,29 @@
 //	}
 	for (int i=0; i<n; i++) {
 		x.code = d[i].code;
-		x.t = v->init_t * d[i].t / 100;            
-		//x.f = v->samp_rate * 100 / (v->init_f * d[i].f); // fixed 20.9.2002 by Petr
+		x.t = v->init_t * d[i].t / 100;            // fixed 8.7.98 by Petr
+		if ((v->use_bang_nnet) && (v->lpcprosody)) {
+		  // excitation value from nnet
+		  x.f = d[i].f; // direct value from nnet to be passed
+		  // printf ("direct output value %d from nnet to %d!\n", d[i].f, x.f);
+		}
+		else {
+		  // all other methods process the value
 		x.f = v->init_f * d[i].f / 100;
+		  // yes, this is too complex! make it easier, please
+		  x.f = v->init_f - x.f;
+		  x.f = x.f * ((double) cfg->pros_factor) / 1000.0;
+		  x.f = v->init_f - x.f;
+		  // printf ("x.f after %d\n", x.f);
+		}
 		x.e = v->init_i * d[i].e / 100;
 		if (cfg->label_seg || cfg->label_phones) {
-			char tmp[4];
+			char tmp[7];
 			if (cfg->label_seg) {
-				strncpy(tmp, ((char(*)[4])v->segment_names->data)[d[i].code], 3);
-				tmp[3] = 0;
+			  // strncpy(tmp, ((char(*)[4])v->segment_names->data)[d[i].code], 3);
+			  snprintf (tmp, 7, "%d", d[i].code);
+			  // printf ("%d is segmentcode\n", d[i].code);
+			  tmp[7] = 0;
 				w->label(0, tmp, enum2str(cfg->segm_level, cfg->unit_levels));
 			}
 			int oi = w->get_buffer_index();
@@ -147,6 +165,10 @@
 //				FILE *f = fopen("02tmp", "a+"); fputs(enum2str(level, cfg->unit_levels), f); fputs("\n", f); fclose(f);
 				w->label(negoffs, tmp, enum2str(level, cfg->unit_levels));
 			}
+			// label again (this time its the 'offset', if i undestood that right)
+			if (cfg->label_f0) {
+				w->label (0, "-", "pitch");
+			}
 		} else 	synseg(v, x, w);
 	}
 }
diff -rub ep2-4-81/src/tdpsyn.cc ep2-4-81-dan/src/tdpsyn.cc
--- ep2-4-81/src/tdpsyn.cc	Fri Sep 20 15:10:54 2002
+++ ep2-4-81-dan/src/tdpsyn.cc	Mon May 12 20:26:06 2003
@@ -31,6 +31,10 @@
 #define F0_FILT_ORD 9			/* F0 contour filter order */
 #define LP_EXC_MUL 1.0			/* LP excitation multipicator */
 
+#ifdef WIN32
+#define snprintf _snprintf
+#endif
+
 /* F0 contour filter coefficients */
 const double a[9] = {1,-6.46921563821389,18.43727805607084,-30.21344177474595,31.11962012720199,
 					-20.62061607537661,8.58111044795433,-2.04983423923570,0.21516477151414};
@@ -39,7 +43,10 @@
 					-0.43840842338467,0.25181616063735,-0.08930749676388,0.01477848982115};
 
 /* lp f0 contour filter coefficients (mean of 144 sentences from speaker Machac) */
-const double lp[LP_F0_ORD] = {-1.23761, 0.60009, -0.32046, 0.10699};
+// const double lp[LP_F0_ORD] = {-1.23761, 0.60009, -0.32046, 0.10699};
+
+// these coeffs are from the version where the f0 has the same value over a syllable
+const double lp[LP_F0_ORD] = {-0.900693, 0.043125, -0.003700, 0.069916};
 // FIXME! lp coefficients must be configurable
 
 /* Hamming coefficients for TD-PSOLA algorithm */
@@ -105,6 +112,7 @@
 
 	tdi = claim(v->models, v->loc, cfg->inv_base_dir, "rb", "inventory", NULL);
 	hdr = (tdi_hdr *)tdi->data;
+	printf ("Got %d and config says %d\n", hdr->n_segs, v->n_segs);
 	if (v->n_segs != hdr->n_segs) shriek(463, "inconsistent n_segs");
 	if (sizeof(t_samp) != hdr->samp_size) shriek(463, "inconsistent samp_size");
 	tdp_buff = (t_samp *)(hdr + 1);
@@ -112,6 +120,11 @@
 	diph_len = diph_offs + v->n_segs;
 	ppulses = diph_len + v->n_segs;
 
+	// this is debugging only!
+#if 1
+	printf ("Samples are %d long.\n", sizeof(t_samp) * hdr->bufpos);
+#endif
+
 	/* allocate the maximum necessary space for Hamming windows: */	
 //	max_frame = 0;
 //	for (int k = 0; k < v->n_segs; k++) {
@@ -142,6 +155,13 @@
 		basef0 = v->init_f;
 		lppitch = v->samp_rate / basef0;;
 	}
+
+	// init the smoothing filter
+	if (v->use_f0_smoothing) {
+		int i;
+		for (i = 0; i < MAX_OFILT_ORDER; smoothfilt[i++] = 0);
+		lppitch = v->samp_rate / basef0;
+	}
 }
 
 tdpsyn::~tdpsyn(void)
@@ -153,7 +173,8 @@
 
 inline int tdpsyn::average_pitch(int offs, int len)
 {
-	const int npitch = 145;
+	// const int npitch = 145;
+	const int npitch = 580;
 	int tmp;
 
 	int total = 0;
@@ -176,11 +197,18 @@
 {
 	int i, j, k, l, m, slen, nlen, pitch, avpitch, origlen, newlen, maxwin, skip, reply, diflen;
 	double outf0, synf0, exc;
+	static double old_exc = 0;
 	t_samp poms;
 	
 	const int max_frame = this->max_frame;
+	int pitch_saved = 0;
+
+	int segment_pitch;
 
-	if (diph_len[d.code] == 0) {
+	printf ("----------------------------------------------------------\n");
+
+	//	if (diph_len[d.code] == 0) {
+	if (0) {
 		DEBUG(2,9, fprintf(STDDBG, "missing speech unit No: %d\n", d.code);)
 		if (!cfg->paranoid) return;
 		shriek(463, fmt("missing speech unit No: %d\n",d.code));
@@ -188,15 +216,47 @@
 
 	/* lp prosody reconstruction filter excitation signal computing */
 	if (v->lpcprosody) { 	// in d.f is excitation signal value
+
+	  // impuls at start of each sentence clears the lpc filter
 		if (d.e >= v->init_i * 9) {
 			for (i = 0; i < LPC_PROS_ORDER; lpfilt[i++] = 0);
 			d.e = (d.e * 100 / v->init_i - 1000) * v->init_i / 100;
 		}
+
+	  if (v->use_bang_nnet) {
+	    // multiply with 13.4 if f0 filter is used
+	    exc = ((float) d.f) / 1000;
+	    // exc = (int) (((float) d.f) * 13.4);
+	    
+	    // delete excitation if it was the same (do not allow more than one exc per syllable)
+	    if (exc == old_exc) {
+	      exc = 0;
+	    }
+	    else {
+	      old_exc = exc;
+	    }
+	    printf ("Version lpc with nnet, exc. is %f\n", exc);
+	  }
+	  else {
 		exc = LP_EXC_MUL * (d.f - v->init_f);
+	    // printf ("Version lpc, exc is %f\n", exc);
+	  }
+
 		pitch = lppitch;
+
 	}
-	else				// in d.f is f0 contour value
+	else {				// in d.f is f0 contour value
 	pitch = v->samp_rate / d.f;
+	  // printf ("Version without lpc, pitch is %d\n", pitch);
+	}
+
+	if (v->use_f0_smoothing) {
+		segment_pitch = pitch; // remember pitch for whole segment
+		if (lppitch > 0) {
+			pitch = lppitch; // use pitch from last segment
+		}
+	}
+
 	slen = diph_len[d.code];
 	avpitch = average_pitch(diph_offs[d.code], slen);
 	maxwin = avpitch + MAX_STRETCH;
@@ -215,14 +275,23 @@
 	if (origlen > newlen) reply = origlen / newlen;
 	//printf("dlen=%d p:%d avp=%d oril=%d newl=%d difl=%d",diph_len[d.code],pitch,avpitch,origlen,newlen,diflen);
 	nlen = slen - (skip - 1) * slen / skip + (reply - 1) * slen;
+	if (nlen == 0) {
+	  printf ("Error: Pitch modelling exceeds range!\n");
+	  nlen = 1;
+	}
 	diflen = (newlen - origlen - (skip - 1) * slen * pitch / skip + (reply - 1) * slen * pitch) / nlen;
 	//printf(" -> diflen:%d sk:%d rp:%d\n",diflen,skip,reply);
 	for (j = 1; j <= diph_len[d.code]; j += skip) for (k = 0; k < reply; k++) {
 		memcpy(out_buff + max_frame - pitch, out_buff + max_frame, pitch * sizeof(*out_buff));
 		memset(out_buff + max_frame, 0, max_frame * sizeof(*out_buff));
 		for (i = -maxwin;i <= maxwin; i++) {
+			long ttemp;
 			poms = tdp_buff[i + ppulses[diph_offs[d.code] + j - 1]];
-			poms = (t_samp)(wwin[i + pitch] * poms >> HAMMING_PRECISION);
+			ttemp = wwin[i + pitch];
+			ttemp *= poms;
+			ttemp = ttemp >> HAMMING_PRECISION;
+			poms = (t_samp) ttemp;
+			//			poms = (t_samp)(wwin[i + pitch] * poms >> HAMMING_PRECISION);
 //			poms = poms * d.e / 100;
 			out_buff[max_frame + i] += poms;
 		}
@@ -245,7 +314,13 @@
 							lpfilt[m] = lpfilt[m-1];
 						}
 						lpfilt[0] = synf0;
+						pitch_saved = 1;
+						// printf ("Unsmoothed synf0 is: %f\n", synf0);
 					}
+
+					// skip f0 filter here
+					if (! (v->use_bang_nnet)) {
+					// if (1) {
 					ofilt[0] = synf0;
 					synf0 = 0;
 					for (m = 1; m < F0_FILT_ORD; m++) ofilt[0] -= a[m] * ofilt[m];
@@ -253,12 +328,34 @@
 					for (m = 0; m < F0_FILT_ORD; m++) outf0 += b[m] * ofilt[m];
 					//printf("of=[%.3f %.3f %.3f %.3f %.3f %.3f %.3f %.3f %.3f]\n",ofilt[0],ofilt[1],
 					//	ofilt[2],ofilt[3],ofilt[4],ofilt[5],ofilt[6],ofilt[7],ofilt[8]);
+					  
+					  // amplify the signal
+					  // outf0 = outf0 * 13.4;
+					}
+					else {
+					  outf0 = lpfilt[0];
+					}
+
+					// apply the prosody factor
+					// 1000 = prosody unchanged
+					// > 1000 = prosody enhanced
+					// < 1000 = prosody lowered
+					outf0 = outf0 * ((double) cfg->pros_factor) / 1000.0;
+					
+					// do remember the first output value from the lpc filter 
+					if (pitch_saved == 1) {
+					  pitch_saved = 2;
 					lppitch = (int)(v->samp_rate / (basef0 + outf0));
+					}
+					// printf ("New values: outf0 : %f, lppitch : %d\n", outf0, lppitch);
 					outf0 = 0;
 					for (m = F0_FILT_ORD - 1; m > 0; m--) ofilt[m] = ofilt[m - 1];
 				}
 			}
 		}
+
+		// printf ("Pitch: %d\n", pitch);
+
 		w->sample((SAMPLE *)out_buff + max_frame - pitch, pitch);
 		//printf("  j:%d difpos:%d diflen:%d",j,difpos,diflen);
 		difpos += diflen;
@@ -273,5 +370,61 @@
 			difpos -= pitch;
 		}
 		//printf(" -> j:%d difpos:%d\n",j,difpos);
+
+		// inserted to label f0 in wav file
+		if (cfg->label_f0) {
+			
+			// printf ("Labelling file!\n");
+			
+			char tmp[4];
+			snprintf (tmp, 4, "%d", pitch);
+			tmp[3] = 0;
+			w->label(0, tmp, "pitch");
+		}
+
+		// f0 smoothing, when chosen
+		if (v->use_f0_smoothing) {
+
+			smoothfilt[0] = segment_pitch;
+
+			for (m = 1; m < F0_FILT_ORD; m++) {
+				smoothfilt[0] -= a[m] * smoothfilt[m];
+			}
+			
+			lppitch = 0;
+			for (m = 0; m < F0_FILT_ORD; m++) lppitch += b[m] * smoothfilt[m];
+			
+			for (m = F0_FILT_ORD - 1; m > 0; m--) smoothfilt[m] = smoothfilt[m - 1];
+
+			if (lppitch > 0) 
+				pitch = lppitch;
+
+			slen = diph_len[d.code] - j + 1;
+			avpitch = average_pitch(diph_offs[d.code] + j - 1, slen);
+			maxwin = avpitch + MAX_STRETCH;
+			maxwin = (pitch > maxwin) ? maxwin : pitch;
+			if (maxwin >= max_frame) shriek(461, "pitch too large");
+		
+			if (d.t > 0) origlen = avpitch * slen * d.t / 100; else origlen = avpitch * slen;
+			newlen = pitch * slen;
+			
+			hamkoe(2 * maxwin + 1, wwin, d.e, 100);
+			skip = 1; reply = 1;
+			if (newlen > origlen) skip = newlen / origlen;
+			if (origlen > newlen) reply = origlen / newlen;
+			
+			nlen = slen - (skip - 1) * slen / skip + (reply - 1) * slen;
+			if (nlen == 0) {
+				printf ("Error: Pitch modelling exceeds range!\n");
+				nlen = 1;
+			}
+			diflen = (newlen - origlen - (skip - 1) * slen * pitch / skip + (reply - 1) * slen * pitch) / nlen;
+			
+
+		}
+
+
+
+
 	}
 }
diff -rub ep2-4-81/src/tdpsyn.h ep2-4-81-dan/src/tdpsyn.h
--- ep2-4-81/src/tdpsyn.h	Fri Sep 20 15:12:35 2002
+++ ep2-4-81-dan/src/tdpsyn.h	Mon May 12 15:42:08 2003
@@ -43,6 +43,7 @@
 	unsigned short *wwin;
 	double lpfilt[LPC_PROS_ORDER];
 	double ofilt[MAX_OFILT_ORDER];
+	double smoothfilt[MAX_OFILT_ORDER];
 	int lppitch;
 	int lpestep;
 	int lppstep;
Only in ep2-4-81-dan/src: tdpsyn_good.cc
Only in ep2-4-81-dan/src: tdpsyn_test.cc
Only in ep2-4-81-dan/src: test.c
Only in ep2-4-81-dan/src: test_f0_filter.c
Only in ep2-4-81-dan/src: test_f0_freq_filter.c
diff -rub ep2-4-81/src/text.cc ep2-4-81-dan/src/text.cc
--- ep2-4-81/src/text.cc	Sun Nov  4 17:58:03 2001
+++ ep2-4-81-dan/src/text.cc	Tue Jan 14 13:04:48 2003
@@ -192,6 +192,7 @@
 			continue;
 		} else if (begins(buffer, D_CHARSET)) {
 			charset = load_charset(get_quoted(buffer));
+			cfg->charset = charset;
 			if (charset == CHARSET_NOT_AVAILABLE)
 				shriek(812, fmt("%s:%d Charset not available", current_file, current_line));
 			continue;
Only in ep2-4-81-dan/src: tsrtool
diff -rub ep2-4-81/src/ttscp.cc ep2-4-81-dan/src/ttscp.cc
--- ep2-4-81/src/ttscp.cc	Sat Aug 17 19:52:11 2002
+++ ep2-4-81-dan/src/ttscp.cc	Tue Mar  4 13:13:39 2003
@@ -141,7 +141,7 @@
 static inline int do_set(char *param, context *real)
 {
 	char *value = split_string(param);
-	option *o = option_struct(param, this_lang->soft_options);
+	epos_option *o = option_struct(param, this_lang->soft_options);
 
 	if (o) {
 		if (access_level(this_context->uid) >= o->writable) {
@@ -254,7 +254,7 @@
 int do_show(char *param)
 {
 	int i;
-	option *o = option_struct(param, this_lang->soft_options);
+	epos_option *o = option_struct(param, this_lang->soft_options);
 
 	if (o) {
 		if (access_level(this_context->uid) >= o->readable) {
diff -rub ep2-4-81/src/unit.cc ep2-4-81-dan/src/unit.cc
--- ep2-4-81/src/unit.cc	Sun May 11 22:27:21 2003
+++ ep2-4-81-dan/src/unit.cc	Wed May 14 17:26:18 2003
@@ -15,6 +15,7 @@
  */
 
 #include "common.h"
+#include "neural.h"
 
 #define QUESTION_MARK      '?'    // ignored context character (in segment names)
 
@@ -552,6 +608,84 @@
 						goto break_home;
 			}
 		}
+
+		if (method & M_MYSUBST) {
+			// shriek(462, fmt("I reached rule mysubst!\n", 50));
+
+			// algorithm similar to M_BEGIN, but continue through the rest of the string, until nothing found and string processed
+			char* real_tail = strend;
+			char* real_begin = gb;
+			char* temp_tail;
+
+			int subst_amount;
+
+			char* temp_buffer = NULL;
+			
+			// stop if the whole string was processed
+			while (real_begin < real_tail) {
+				for (tail = real_tail;tail > real_begin; tail--) {
+					bool subst_result;
+					
+					if (real_begin == gb) {
+						subst_result = subst(table, l, gb, real_begin, real_begin, tail, strend);
+					}
+					else {
+						subst_result = subst(table, l, NULL, NULL, real_begin, tail, strend);
+					}
+						
+					if (subst_result) {
+						DEBUG(1,3,fprintf(STDDBG,"inner unit::subst has substituted %s\n", real_begin);)
+						break;
+					}
+					else {
+						DEBUG(1,3,fprintf(STDDBG,"inner unit::%s could not be substituted\n", real_begin);)
+					}
+					tail[0] = tail[-1]; tail[-1] = 0;
+				}
+
+				// undo the changes made to the string
+				for (temp_tail = tail; temp_tail <= real_tail; temp_tail++) {
+					temp_tail[-1] = temp_tail[0];
+					temp_tail[0] = 0;
+				}
+				
+				subst_amount = (int) ((tail) - (real_begin));
+
+				DEBUG(1,3,fprintf(STDDBG,"inner unit::subst has substituted %d letters\n", subst_amount);)
+
+				if (temp_buffer == NULL) {
+					temp_buffer = (char *) xmalloc (1000);
+					memset (temp_buffer, 0, 1000);
+				}
+				if (subst_amount > 0) {
+					strcat (temp_buffer, sb);
+				}
+				else {
+					char tmp[2];
+					tmp[0] = real_begin[0];
+					tmp[1] = 0;
+					strcat (temp_buffer, tmp);
+				}
+
+				DEBUG(1,3,fprintf(STDDBG,"inner unit::subst temp_buffer contains %s \n", temp_buffer);)
+				
+
+				if (tail == real_begin) {
+					// nothing was found
+					real_begin++;
+				}
+				else {
+					// found sth., skip the substituted string
+					real_begin = tail;
+				}
+			}
+			
+			if (sb != NULL) free (sb);
+			sb = temp_buffer;
+			subst();
+			goto break_home;
+	
+		}
 		cont = separ;
 		if (method & (M_LEFT | M_RIGHT) && method & M_NEGATED) {
 			unlink(method&M_LEFT ? M_LEFTWARDS : M_RIGHTWARDS);
@@ -923,6 +1057,9 @@
 	unit *u;
 	int i;
 	int padd_count;
+
+	DEBUG(1,2,fprintf(STDDBG, "unit::contour (%d) %d %d ...\n", rec_len, recipe[0], recipe[1]);)
+
 	for (u = LeftMost(target), i = (padd_start > -1);
 			i < rec_len && u != &EMPTY;
 			u = u->Next(target), i++)  /* just count'em */ ;
@@ -1328,5 +1465,15 @@
     	if (father) father->fout(NULL);
 }
 
-#include "nnet.cc"
+void 
+unit::neural (UNIT target, CNeuralNet *neuralnet)
+{
+	DEBUG (0,10,fprintf(STDDBG,"applying neuralnet"));
+	sanity ();
+
+	neuralnet->target = target;
+	neuralnet->run (this);
+}
+
+// #include "nnet.cc"
 
diff -rub ep2-4-81/src/unit.h ep2-4-81-dan/src/unit.h
--- ep2-4-81/src/unit.h	Wed May  8 00:48:08 2002
+++ ep2-4-81-dan/src/unit.h	Fri Mar  7 13:25:25 2003
@@ -33,11 +33,13 @@
 
 #define SMOOTH_CQ_SIZE    16		// max smooth request length, see unit::smooth()
 
+class CNeuralNet;
 
 class unit
 {
 	friend void epos_catharsis();	  // necessary only #ifdef WANT_DMALLOC
 	friend class r_inside;
+	friend class t_neuralnet;	  // neuralnet directly writes into f,i,t
 
     public:
 	unit *next, *prev;                //same layer
@@ -76,6 +78,8 @@
                                       // starting_at==0 for the first segment
 	void show_phones();	      // printf() the phones
 	void nnet_out(const char *filename, const char *dirname);
+	void filedump (char *filename);      // for external use of hierarchy information
+	void dumpunitrecursive (FILE *outf);
 	void fout(char *filename);        //stdout if NULL
 	void fprintln(FILE *outf);        //does not recurse, prints cont,f,i,t
 	char *gather(char *buffer_start, char *buffer_end, bool suprasegm);
@@ -132,6 +136,13 @@
 	static int sbsize;
 	static void done();		// free buffers
 	static void assert_sbsize(int);	// at least that big sbsize
+
+	int getCont () const { return cont; }
+	int getDepth () const{ return depth; }
+
+	void neural (UNIT target, CNeuralNet *); 		//JA: Apply neural network described in some cfg file
+	int getF () const	{ return f; }
+	void setF (int ff)	{ f = ff; }
 };
 
 // extern char * _subst_buff;
Only in ep2-4-81-dan/src: unitdumpfile.txt
Only in ep2-4-81-dan/src: versuch.dat
diff -rub ep2-4-81/src/voice.cc ep2-4-81-dan/src/voice.cc
--- ep2-4-81/src/voice.cc	Mon Jul  9 08:46:39 2001
+++ ep2-4-81-dan/src/voice.cc	Tue Mar  4 13:13:53 2003
@@ -79,7 +79,7 @@
 #define TWENTY_EXTRA_OPTIONS EO EO EO EO EO EO EO EO EO EO EO EO EO EO EO EO EO EO EO EO
 
 #define CONFIG_LANG_DESCRIBE
-option langoptlist[] = {
+epos_option langoptlist[] = {
 	#include "options.lst"
 
 	{"L:voice" + 2, O_VOICE, OS_LANG, A_PUBLIC, A_PUBLIC, false, false, 0},
@@ -89,7 +89,7 @@
 };
 
 #define CONFIG_VOICE_DESCRIBE
-option voiceoptlist[] = {
+epos_option voiceoptlist[] = {
 	#include "options.lst"
 	{NULL}
 };
@@ -183,7 +183,7 @@
 	else dflt = const_cast<char *>("");
 	char *closing = (char *)strchr(optname, CLOSING);
 
-	option o;
+	epos_option o;
 	o.opttype = O_BOOL;		// default type
 	o.structype = OS_VOICE;	// soft options can only be voice options
 	o.readable = o.writable = A_PUBLIC;	// ...no access restrictions on them
@@ -210,7 +210,7 @@
 		soft_defaults = xrealloc(soft_defaults,
 				(soft_options->items + 2) * sizeof(void *) >> 1);
 	} else {
-		soft_options = new hash_table<char, option>(30);
+		soft_options = new hash_table<char, epos_option>(30);
 		soft_options->dupkey = 0;
 		soft_defaults = xmalloc(sizeof(void *));
 	}
diff -rub ep2-4-81/src/voice.h ep2-4-81-dan/src/voice.h
--- ep2-4-81/src/voice.h	Thu Oct 11 12:07:06 2001
+++ ep2-4-81-dan/src/voice.h	Tue Mar  4 13:14:10 2003
@@ -51,7 +51,7 @@
    #include "options.lst"
 
 	rules *ruleset;
-	hash_table<char, option> *soft_options;
+	hash_table<char, epos_option> *soft_options;
 	void *soft_defaults;
 	int   n_voices;
 	voice **voices;
@@ -102,8 +102,8 @@
 #define this_lang  (cfg->langs[cfg->default_lang])
 #define this_voice (this_lang->voices[this_lang->default_voice])
 
-struct option;
+struct epos_option;
 
-extern option langoptlist[];
-extern option voiceoptlist[];
+extern epos_option langoptlist[];
+extern epos_option voiceoptlist[];
 
