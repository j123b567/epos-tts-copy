
<sect> Source Code Documentation
<p>

This section is of little use for anyone except for programmers willing to contribute
to the development of Epos or going to modify its source code. It is also not
trying to become a beginner's guide to Epos. Anyway, if you are personally missing
something here or elsewhere, tell me and I may add it; that will become almost the only
source of progress in this section of documentation. The section may also slowly
become outdated due to lack of interest.

<sect1> Design goals
<p>

Overall coding priorities, approximately in order of decreasing precedence:
<itemize>
	<item> language independence and generality
	<item> no undocumented or implicit "features"
	<item> portability
	<item> maintainability, clean decomposition
	<item> clean (intuitive) protocols and programming interfaces
	<item> scalability
	<item> intuitive configuration
	<item> fault tolerance
	<item> simple algorithms
	<item> code readability
	<item> speed
	<item> space
	<item> possible paralelizability
</itemize>

<sect1> Isolated classes
<p>

<tt/class parser, unit, rules, text/ and maybe a few others are isolated classes
that take no advantage from inheritance. The reason for the class-oriented design
is just a matter of code readability and decomposition in this case.

<sect2> Class <tt>simpleparser</tt>
<p>

This class takes some input (such as a plain ASCII or STML text) and then can be
used in conjunction with the <tt/class unit/ constructor to build the
<ref id="tsr" name="text structure representation">. Its purpose is to
identify the Latin text tokens (usually ASCII characters, but some traditional
tokens like "..." would be difficult to identify later, as well as numerous other
context dependent uses of "."). The parser also identifies the level of description
which corresponds to the token and this is the information needed by the <tt/class
unit/ constructor to correctly build the <ref id="tsr" name="TSR">. In this process,
the parser skips over any empty units, that is, units that contain no phones
(simple letters) at all.

Note that it is unnecessary and counterproductive to distinguish between homographic
tokens used at the same level of description here; such intelligence can be handled
more flexibly by the language dependent rules. In fact, they tend to be usually
language dependent. The parser only avoids losing information (through empty unit
deletion) by the minimum necessary tokenization.

The STML parser is still unimplemented.

<sect2> Class <tt>unit</tt>
<p>

This class is the fundamental element of the <ref id="tsr"
name="text structure representation">. Its methods are listed in
<tt/elements.h/.  Every object of this type represents a single
text unit.  Every unit includes pointers to its immediate
container, and to its contents. The contents are organized in a
bidirectional linked list; pointers to the head and tail units
of this lists are stored in the unit. These links, i.e. <tt/prev/
and <tt/next/, also serve to locate the neighboring units; they may be
<tt/NULL/, indicating that this is the first/last unit in the
immediate container.  For most uses, these pointers are not suitable
to be used directly; the <tt/Prev/ and <tt/Next/ methods find the
neighbor, even if a higher level boundary lies in between. It is also
possible to mark a unit as a <tt/scope/ one. In this case, the <tt/Next/
and <tt/Prev/ methods will be unable to cross its boundary from inside
out (they will return <tt/NULL/ if this is attempted).  If you need to
modify the TSR directly, you will benefit from calling <tt/unit::sanity/
occasionally. This method checks the TSR structure near the unit which has
called it and will report a severe error, if an invariant is violated,
thus saving you from misguided error messages or crashes later.

To extract the prosodic information from a TSR, call the <tt/effective/
method.  It will combine the prosodic adjustments present at all the levels
of description above the current unit.

<sect2> Class <tt>text</tt>
<p>

This class represents a logical line-oriented text file. It handles things
like the <ref id="include-directive" name="&num;include directive">,
<ref id="escaping" name ="backslash-escaped special characters">,
initial whitespace and comment stripping. It is used for the <ref id="rules"
name="rule files"> and <ref id="cfg-files" name="configuration files">,
but <em/not/ for the <ref id="dictionary" name="dictionaries">.

<sect2> Class <tt>file</tt>
<p>

This class represents a physical data file.  Its main purpose is to cache and
share files repeatedly needed by Epos.  The <tt/claim/ function (to be found in
<tt/interf.cc/) should be used for opening the file (or only sharing an existing
copy if the file is already open) and reading the data out of the file. The
<tt/unclaim/ function is called separately for every <tt/claim/ call whenever
the file is no more needed.

Any code which uses this class should never extract the data member out of it and
use it independently, even if the class itself remains claimed. This is because
if the content of the file has changed, the data in memory will be reallocated and
re-read upon the next call to <tt/claim/ or possibly even sooner. This may cause
invalidation of the original <tt/data/ member at any point of a control switch
to another Epos agent.  It is possible to call <tt/reclaim/ at any time to force
re-reading any file if its time stamp has changed.

<sect2> Class <tt>hash</tt>
<p>

<tt/class hash/ is derived from <tt/class hash&lowbar;table&lt;char,char&gt;/.
The <tt/hash&lowbar;table/ template is a generic hash table, keys and associated
data items being its class parameters. This implementation uses balanced (AVL)
trees to resolve collisions and is able to adjust (rehash) itself 
when it gets too full or too sparse. It is a very robust and fast
implementation and it is independent of the rest of Epos, so you
may use it in other projects if you want to (subject to GPL).
If you want to have the hash table keep a copy of its contents,
the key and/or data may only be of a fixed size type, or a C-style
string. Alternatively, the hash table will only store pointers
to these items. These approaches can be mixed in any reasonable
sense of "mixing".

The hash tables are used frequently in Epos in various type combinations
(see <tt/hash.cc/ for a list. They're also used for parsing the 
<ref id="dictionary" name="dictionary files">.

<sect2> Class <tt>rules</tt>
<p>

Note the difference between <tt/class rules/ and <tt/class rule/.
Every set of rules in Epos (there is one per language) is a <tt/class
rules/, which contains a single <tt/r_block/, which in turn
contains the individual rules.
The <tt/class rules/ serves as the only communication interface
between the <tt/rule/ hierarchy and the rest of Epos, but there
is no inheritance relation between them.



<sect1> Class hierarchies

<sect2> Class <tt>rule</tt>
<p>

Each <tt/rule/ object represents a rule to be applied to 
a structure of units. The class hierarchy:

rule
<itemize>
	<item> r_regress
	<itemize>
		<item> r_progress
	</itemize>
	<item> r_raise
	<item> r_syll
	<item> r_contour
	<item> r_smooth
	<item> r_regex
	<item> r_debug
	<item> hashing_rule
	<itemize>
		<item> r_subst
		<itemize>
			<item> r_prep
			<item> r_postp
		</itemize>
		<item> r_diph
		<item> r_prosody
	</itemize>
	<item> cond_rule
	<itemize>
		<item> r_inside
		<item> r_if
		<item> r_with
	</itemize>
	<item> block_rule
	<itemize>
		<item> r_block
		<item> r_choice
		<item> r_switch
	</itemize>
</itemize>

Classes not beginning in <tt/r_/ can be considered abstract.

<sect2> Class <tt>agent</tt>
<p>

Epos can be configured to support multiple simultaneous TTSCP connections
and excepting bugs, no single unauthorized connection should be able to
create a Denial of Service situation, such as long delays in processing
other connections.  To achieve this, Epos uses a simple cooperative multitasking
facility called <em/agents/. An agent (process) is an entity, which is responsible
for carrying out some task, such as reading a few bytes from a file descriptor.
At any moment (except for the startup and the very moments of a transfer of
control), exactly one agent is active (Epos doesn't support SMP to avoid
the unnecessary overhead and complexity in the typical case).  If an agent has to wait
for some event before its job is finished, for example, when the sound card reaches
full buffers or not enough data has arrived through a network connection, the agent
calls the <tt/block/ method with the offending file descriptor.  It is impossible
to wait for anything except a file descriptor status change.  If an agents wants
to have another agent running, it can call the <tt/schedule/ method to add it
to the queue of runnable processes. The scheduled agents always acquire control
through the <tt/run/ method; when this method returns, another agent is chosen.
If there are no more runnable agents, Epos will wait until an agent becomes runnable
through a status change of the file descriptor the agent is <tt/block/ing for.

Most agents get their data input through the <tt/inb/ data member and place their output
into the <tt/outb/ data member. Whenever the agent has completed a stand-alone chunk
of output, the agent calls the <tt/pass/ method to pass it to its successor and
to schedule it for processing. The output agent never calls <tt/pass/ (it has actually
no successor and it is responsible for writing the data somewhere outside Epos),
but it calls <tt/finis/ when the data has been successfully written.

Most agents are organized into streams of interconnected agents. See the
<ref id="strm-cmd" name="strm command"> for the semantics of that.
Other agents are responsible for individual TTSCP connections, for accepting new
connections and other tasks. A special agent is used for deleting other
agents when they need to delete themselves.

The current agents are:

agent
<itemize>
	<item> stream
	<item> a&lowbar;accept
	<item> a&lowbar;protocol
	<itemize>
		<item> a&lowbar;ttscp
	</itemize>
	<item> a&lowbar;disconnector
	<item> a&lowbar;ascii
	<item> a&lowbar;stml
	<item> a&lowbar;rules
	<item> a&lowbar;print
	<item> a&lowbar;diphs
	<item> a&lowbar;synth
	<item> a&lowbar;io
	<itemize>
		<item> a&lowbar;input
		<item> a&lowbar;output
		<itemize>
			<item> oa&lowbar;ascii
			<item> oa&lowbar;stml
			<item> oa&lowbar;diph
			<item> oa&lowbar;wavefm
		</itemize>
	</itemize>
</itemize>

<sect1> More information
<p>

The header files mostly define basic interfaces for individual Epos components.
Reading the ones related to a specific piece of code may often clarify things.
Lots of global data declarations live in <tt/common.h/; others (especially
small, library-like functions) can be found in <tt/interf.h/.

If you have any code or development related question about Epos, send
it to the Epos development mailing list <htmlurl url="mailto:epos@braille.mff.cuni.cz"
name="epos@braille.mff.cuni.cz">. Please spend a few seconds by trying to look up
the answer in the documentation first.
