
<sect1> Rules
<p>

In SS, nearly all of the TTS processing is controlled by a rule file;
there is one rule file per language and it usually has the <tt>.rul</tt>
suffix. The rule file for the German language, for instance, resides
by default in <tt>lng/german/german.rul</tt>.

FIXME: text units desc

<sect2> Rule file format
<p>

The rules are applied sequentially, unless stated otherwise.
Each rule operates units of a certain level within a unit
of some other level; for instance, a rule may assimilate
phones within a word, another rule may change the syllabic
prosody within a colon. The smaller units being manipulated
are called <em>target units</em>, the larger unit is referred
to as a <em>scope unit</em>; the respective levels are
called <em>scope</em> and <em>target</em>. Each scope unit
is always processed separately (from any other scope units)
as if no other text ever existed. For example, if the scope of some
assimilation happens to be "word", every word will have the rule 
applied in isolation and the assimilation will never apply across
the word boundary. 

Any line of the rules file may contain at most one rule and
possibly some comment.
The rule begins with an operation code specifier (what to do),
followed by the parameter (one word, opcode specific), and possibly
by scope and target specification, if the defaults (usually word
and phone, respectively) are not suitable.

The scope and the target can be one of "diphone", "phone", "syll", "word", "colon",
"sent", and "text". Other levels of description may be added later.
Every rule is evaluated within certain unit, and the scope specifies,
what kind of unit it should be. 
The meaning of the target is somewhat opcode specific,
but generally, this is the level which is affected by that rule.
See individual rule descriptions in conjunction with the actual
files.

The code, scope and target is not case sensitive, but the parameter
usually is.


<sect3> Using comments and the #include directive
<p>

Any text starting with ';' or '#' not in the middle of a word up to the
end of the line is a comment. It will be properly ignored. If a line
doesn't contain anything except whitespace and/or comment, it is also
ignored. The <tt>#include</tt> directive can be used to nest the rule
files.  The same rules apply within <tt>.ini</tt> files; for more
details, see ???

<sect3> Variables (macros)
<p>

CHECKME:
A line, which doesn't contain a rule, may contain a macro definition instead.
It is usually specified as <tt>identifier = replacement</tt>;  macro identifiers
always start with a dollar sign, and the equality sign is facultative, which
allows for this example: <tt>$vowel aeiouy</tt>. As a special case, if the replacement
is the word <tt>external</tt>, the identifier is assigned the value of its correspond-
ing configuration parameter (for the current voice or current language if possible).

The macros will get expanded anywhere where they occur except for their own
point of definition. Therefore, <tt>$vowel  $short$long</tt> will be a valid macro
definition, provided that <tt>$short</tt> and <tt>$long</tt> have already been defined. The
expansion is performed at the definition time and it is not iterated, because
the replacement is not expected to contain the dollar sign.

Macros can later be redefined if you wish and they can be local to a block
of rules as described below.

If there be any uncertainity concerning the exact length of the identifier,
you can use braces to embrace it: <tt>${name}</tt> is usually equal to <tt>$name</tt>, but
<tt>$nameaeiou</tt> is not equal to <tt>${name}aeiou</tt>. It is also possible to use
a colon or an ampersand an a delimiter: <tt>$name&amp;aeiou</tt>.

For an abundance of examples see existing rule files.


<sect3> Blocks of rules
<p>

A block is a sequence of rules enclosed within braces ("<tt>{</tt>" and "<tt>}</tt>").
Both the opening and the closing brace follow the rule syntax, but
they take no parameters except for an optional scope specification.
The block is treated as a single rule, which is useful with conditional
rules like

<verb>
if   condition
{
	do   this
	do   that
}
</verb>

The rules are applied sequentially, as you would expect, for every
unit of the proper size as given by the scope of the opening brace.
This means that every word (if the scope is <tt>word</tt>) is processed
separately throughout all the rules in the block. This involves
some splitting of execution on entering the block. By default, no
such splitting is done and the block inherites its scope from its
master rule (a conditional rule, a block it is encapsulated in,
or the global implicit block which covers all the rules altogether).
Consequently, the scope of any enclosed rule may not be larger
than the scope of the block.

Any macros defined in the block are local to the block. The semantic
details are C-like and are by no means important.


<sect3> Choices of rules
<p>

A choice is a sequence of rules enclosed within brackets ("<tt>[</tt>" and "<tt>]</tt>").
Both the opening and the closing bracket follow the rule syntax, but
they take no parameters except for possible scope specification.
The choice is treated as a single rule.

Whenever the choice is applied, one of its subordinate rules is chosen
nondeterministically for every unit of the proper size as given by the
scope of the opening brace, and only this rule is applied.

Generally, choices behave like blocks; the main difference is that with
blocks, all of the rules are applied, whereas with choices, exactly one
of them gets applied (possibly different rules for different pieces of
the text processed).

Empty choices (with no rules within) are not tolerated, contrary
to empty blocks.


<sect3> Length-based selection of rules
<p>

A (length-based) switch is a sequence of rules enclosed within angle
brackets ("<tt>&lt;</tt>" and "<tt>&gt;</tt>"). Both the opening and the closing bracket follow
the rule syntax, but they take no parameters except for possible scope
and target specification. The switch is treated as a single rule.

Whenever the switch is applied to a scope unit, target units contained
within are counted. If <tt>n</tt> units are found, the <tt>n</tt>-th rule in sequence of
the subordinate rule is applied. 

If there is less than <tt>n</tt> rules available, the last one will be used.
You can avoid this behaviour by specifying "nothing" after the last rule.


<sect3> Repeated rules and choice probabilities
<p>

Write "<tt>3x</tt>" before a rule to repeat it three times (in a block)
or to make it three times more probable (in a choice):

<verb>
[
	3x prosody		typical.dic
	   prosody		variant.dic
]
</verb>

(The first alternative now has 75% of being chosen, while
the other one is left for the remaining 25%.)

The repeat count must be a positive integer. You can not use
this feature just after conditional rules, because repeated
rules are not counted as a single rule for syntactic purposes:
	
<verb>
	if  $something
		2x   regress   0>x(!_!)	  #...wrong!
</verb>
		
You should rewrite this to

<verb>
	if  $something
	{
		2x   regress   0>x(!_!)
	}
</verb>

Huge integers (like one million) are disallowed. This is because
the current implementation needs a few bytes of memory (one pointer)
per every repetition.











<sect3>Individual rule types
<p>

Roughly speaking, there are two classes of rules - rules whose parameter is a filename
(of a file which holds specific, possibly very large data), and rules
whose parameter describes the rule in itself. In the following enumeration,
the rules which refer to some file are mostly presented first. All of them
use a generic file structure. The file consists of multiple lines, whose
order is not significant; it may contain comments according to hash.doc,
but not <tt>#include</tt> directives.
Every line consists of two words separated by whitespace and the words
will hence be called <em>replacee</em> and <em>replacer</em>, respectively.

Instead of a file name reference, it is possible to quote the contents
of the dictionary directly; this is done by encapsulating the contents
in double quotes. Dictionary items are whitespace-separated, the replacer
and replacee are separated with a comma. Useful for very small dictionaries.

<sect4> Type <tt>subst</tt>
<p>

  Substring substitution. The replacers replace every occurence
  of their respective replacees; longer matches are matched first; the
  process is iterated until no replacee occurs in the string. It is required
  either to have a <tt>phone</tt> target, or to keep all the replacers
  and replacees of the same length, because it is not obvious how to handle the
  children of the units affected.

  Infinitely looping substitutions are currently reported as an error
  condition.

<sect4> Type <tt>prep</tt>
<p>

  Preposition. If the scope unit is identical to some replacee,
  it gets replaced with its respective replacer and merged to its right-hand
  neighbor. If there is no such neighbor, nothing happens. Again, the target
  must currently be <tt>phone</tt> or all the replacers of sizes corresponding
  to their respective replacees.

<sect4> Type <tt>postp</tt>
<p>

  Postposition. See type <tt>prep</tt>, but the resultant unit is merged to its
  left-hand neighbor.

<sect4> Type <tt>prosody</tt>
<p>

  See doc/*/prosody.doc for details on this rule type. FIXME: should be merged here.

<sect4> Type <tt>diphones</tt>
<p>

  Setup the diphones. See doc/*/diphones.doc for details. FIXME: should be merged here.

<sect4> Type <tt>regex</tt>
<p>

  Regular expression substitution. The parameter is of the form
  <tt>/regular_expression/replacement/</tt>. This rule type is similar to <tt>subst</tt>,
  but it is more powerful and more arcane; it is not intended for end
  wizards. Skip it.
  
  For a regular expressions' overview  try <tt>man grep</tt>. Note a difference:
  in "regular" regular expressions, parentheses match themselves, while
  the open group and close group operators are <tt>\(</tt> and <tt>\)</tt>, respectively.
  As we use groups heavily and next to none real parentheses, we decided
  to do it the other way round.
  
  The replacement may contain escape sequences referring to the match of
  the <tt>n</tt>-th group within the regular expression: <tt>\1</tt> to <tt>\9</tt>.
  <tt>\0</tt> represents the entire match, but this is probably unusable under the
  current design, as this would cause an infinite substitution loop.
  
  In order to use this type of rule, you need to have the <tt>rx</tt> or <tt>regex</tt>
  library already installed and have <tt>WANT_REGEX</tt> enabled in <tt>common.h</tt>.
  This is because we don't actually implement the regex parsing stuff; we leave it
  to your OS libraries. In case you don't have such libraries installed, we use
  the glibc implementation (<tt>rx.c</tt> in the distribution).

<sect4> Type <tt>raise</tt>
<p>

  Move a unit to another level of description, e.g. when a segment
  level unit should directly affect the prosody. The parameter is of the form
  <tt>from:to</tt> (<tt>from</tt> and <tt>to</tt> are arbitrary strings,
  they can employ the "except" operator (exclamation mark). The tokens
  in <tt>from</tt>, if found at the target
  level, are copied to the scope level, if the original scope token is listed
  in <tt>to</tt>. It is also possible to omit the colon and the <tt>to</tt> string; the default
  interpretation is "everywhere".

<sect4> Type <tt>regress</tt>
<p>

  Assimilation, elision or other mutation of phones or other units
  depending on their immediate environment. The parameter is of the form
  <tt>o&gt;n(l_r)</tt>, where o,n,l,r are arbitrary strings. The semantic is "change tokens
  in <tt>o</tt> to their corresponding tokens in <tt>n</tt>
  whenever the left neighbour is in <tt>l</tt>
  and right one is in <tt>r</tt>". The first two strings should therefore either be of
  equal length, or <tt>n</tt> should be a single character, with the obvious inter-
  pretations of "corresponding".

  The zero character (<tt>0</tt>0) may be included in any of the strings; it means
  "no element", and it can be used to insert new units, delete the old ones,
  and to limit the change to the beginning or the end of the scope unit,
  respectively. On the other hand, if the contents of some unit is literal <tt>0</tt>
  before the application of this rule, it will stay untouched. Use e.g.
  <tt>regex</tt> or <tt>subst</tt> rules to handle this case properly.

  Examples:   
<verb>
	regress  0>'(0_aeiou)  word  phone
</verb>
  inserts the apostrophe before the vowels listed at the beginning of a word.
<verb>
	regress  $voiceless>$voiced(!_$voiced)  word  phone
</verb>
  assimilates voiceless consonants to their voiced counterparts (assuming
  <tt>$voiced</tt> and <tt>$voiceless</tt> have been defined previously), when the're followed
  by a voiced consonant. The change proceeds from the right to the left,
  therefore <tt>ppb</tt> will change to <tt>bbb</tt>. See below for the explanation of the
  exclamation mark (here: "everywhere").

<sect4> Type <tt>progress</tt>
<p>

  As above, but the change proceeds from left to right. In the second
  example for the <tt>regress</tt> rule, the result would be <tt>pbb</tt>
  if <tt>progress</tt> was employed.

<sect4> Type <tt>syll</tt>
<p>

  Roughly speaking, this rule type can be used to split words to
  syllables according to the theory of sonority, i.e. at the least sonorous
  phones. More generally, it could be used to do any sort of inserting unit
  boundaries depending on local values of a simple metric.

  The parameter is an ordering of the target units (typically, phones).

Example:
<verb>
	syll  0<ptkf<bdgv<mnN<lry<aeiou"  syll  phone
</verb>
  inserts the following (and other) syllable boundaries:
<verb>
  a|pa  ap|pa  ap|ppppa  arp|pa  ar|pra  a|pr|pa
</verb>

  Tokens not listed are considered least sonorous, order of tokens within
  the same sonority group (see the example) is irrelevant.

  (It is possible (using the <tt>suppress_side_syll</tt> and
  <tt>limit_side_syll</tt> options in conjuction) to forbid
  the formation of a unit with an insufficiently sonorous
  element at its first position. This crude feature allows
  us to avoid the unwanted "side syllables" in Czech and is
  off by default. A language independent solution is not
  known, especially because the authors are not certain
  about similar phenomena in other languages. Please contact
  us if you can comment on syllabification irregularities
  in natural languages. We'll be happy to replace this
  "feature" with something generic.  See the source
  (<tt>unit::syllablify</tt>) for any other details.)

<sect4> Type <tt>contour</tt>
<p>

  FIXME: To be yet documented - assigns prosodic contours.
  See real world examples at the moment.

<sect4> Type <tt>smooth</tt>
<p>

  Smoothing out of one of the F,I,T quantities. The parameter is
  <tt>quantity/left_weights/base_weight\right_weights</tt>; the <tt>left_weights</tt>,
  if there're multiple ones, shall be slash separated, the <tt>right_weights</tt> shall
  be backslash separated. The new value of the quantity specified for any
  target is computed as a weighted average of the values for the surrounding
  units at the same level. If the target is too near to the scope boundary
  to have enough neighbours in some direction, the value for the last unit
  in that direction instead.

  Example:
<verb>
	smooth  i/10/20/40\20\10  word  syll
</verb>
  applied to the second word </tt>un-ne-ce-ssa-ry</tt> will adjust intensity values
  for all of the syllables. E.g. the second syllable will be computed as
  0.3 x i("<tt>un</tt>") + 0.4 x i("<tt>ne</tt>") + 0.2 x i("<tt>ce</tt>") + 0.1 x i("<tt>ssa</tt>")

  The computations for different units do not interfere. The weights can
  also be specified as negative quantities and/or as sums of more values.
  This permits linear parametrization of the rules.
  
  FIXME: Explanation of <tt>unit::project</tt> is missing here.

<sect4> Type <tt>debug</tt>
<p>

  Debugging information during the application of the rules.
  Scope and target are ignored, the parameter is parsed lazily.

  Parameter "<tt>elem</tt>": dump the current state of the text being processed
  Parameter "<tt>pause</tt>": wait until keypress

<sect4> Type <tt>inside</tt>
<p>

  Apply a rule or a block of rules within certain units only.
  The parameter is a list of values at the scope level, wherein the
  following rule should be applied; the "except" operator may be used.

  Every unit (a sentence, for example), which fullfills the criterion,
  is processed separately, therefore the following rule's scope may
  be at most that of the <tt>inside</tt> rule itself.

<sect4> Type <tt>with</tt>
<p>

  Apply a rule or a block of rules for a list of units.
  In contrast with the preceding rule type, this refers not only
  to the token at the scope level (such as space), but to the whole
  structure (such as the string of phones delimited by the space).
  
  The parameter is a filename; the file should list the strings
  subject to the following rule, such as special words.

<sect4> Type <tt>if</tt>
<p>

  Apply a rule or a block of rules only if a condition (given
  by the parameter) is met. The condition must currently be specified
  as a string comparison test - <tt>string1==string2</tt>. The following rule
  is applied only if the strings are identical after the macro expansions.

  Again, the subordinate rule's scope may not be larger than that of
  the <tt>if</tt> rule itself.


<sect3> The "except" (<tt>!</tt>) operator
<p>

Whenever an unordered list of tokens should be specified within the parameter
to some rule (use common sense and/or individual rule descriptions above),
you can also make negative specifications, such as "all consonants except
l and r". To do this, use the exclamation mark serving as an "except" operator:
<tt>$consonants!lr</tt> (The right operand is subtracted from the left one.)
If there is no left operand, say in <tt>!x</tt>, the semantics is "all but x".
You see that <tt>!</tt> alone means "everything".

The operator is right-associative; <tt>!$vowels!ou</tt> means "all excluding vowels,
but <tt>o</tt> and <tt>u</tt> don't count as vowels just now".

Let us repeat that this operator will never work for ordered lists, not even
for the <tt>syll</tt> rule sonority groups.


<sect3> Escaping special characters
<p>

You can use the backslash to escape any special character including itself
anywhere in the rules or <tt>.ini</tt> file strings. <tt>\n</tt>, <tt>\t</tt>, <tt>\[</tt> may be used
to insert a newline, tab, or escape characters, respectively.

<sect2> FIXME: more info on rules
