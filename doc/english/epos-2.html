<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.6">
 <TITLE>               The Epos Speech System: Rules </TITLE>
 <LINK HREF="epos-3.html" REL=next>
 <LINK HREF="epos-1.html" REL=previous>
 <LINK HREF="epos.html#toc2" REL=contents>
</HEAD>
<BODY>
<A HREF="epos-3.html">Next</A>
<A HREF="epos-1.html">Previous</A>
<A HREF="epos.html#toc2">Contents</A>
<HR>
<H2><A NAME="rules"></A> <A NAME="s2">2. Rules </A></H2>

<P>
<P>In Epos, nearly all of the TTS processing is controlled by a rule file;
there is one rule file per language and it usually has the <CODE>.rul</CODE>
suffix.  The rule file for the German language, for instance, resides
by default in <CODE>lng/german/german.rul</CODE>. The rules may also slightly
vary for the individual voices using the 
<A HREF="epos-3.html#soft-options">soft options</A>.
<P>
<H2><A NAME="tsr"></A> <A NAME="ss2.1">2.1 Text Structure Representation overview </A>
</H2>

<P>
<P>The text being processed by Epos is internally stored in a format
suitable for the application of transformational rules.  Every phonetic
unit (or an approximation of one) is represented by a single node in the
structure. The nodes are organized into layers corresponding to linguistic
levels of description, such that a unit of level <CODE>n</CODE> can list its
immediate constituents, that is units of level <CODE>n-1</CODE>. Every layer
also has a symbolic name, which is used to refer to it in the rules.
<P>The number and symbolic names of individual levels can be specified
with the <CODE>unit_levels</CODE> option before the languages are defined.
An example can be given:
<P>
<A NAME="tsr-levels"></A> <P>
<CENTER><TABLE BORDER><TR><TD>
<BR>
Level name </TD><TD> written TSR semantics </TD><TD> spoken TSR semantics </TD></TR><TR><TD>
<CODE>text</CODE> </TD><TD>     the whole text  </TD><TD> the whole text </TD></TR><TR><TD>
<CODE>sent</CODE> </TD><TD>     sentence construction   </TD><TD> terminated utterance </TD></TR><TR><TD>
<CODE>colon</CODE></TD><TD>     sentence/clause/colon   </TD><TD> intonational unit </TD></TR><TR><TD>
<CODE>word</CODE> </TD><TD>     word    </TD><TD> stress unit   </TD></TR><TR><TD>
<CODE>syll</CODE> </TD><TD>     word    </TD><TD> syllable      </TD></TR><TR><TD>
<CODE>phone</CODE></TD><TD>     letter  </TD><TD> sound </TD></TR><TR><TD>
<CODE>diphone</CODE></TD><TD> </TD><TD> diphone </TD></TR><TR><TD>

<CAPTION>       Available Text Structure Representation layers (an example)</CAPTION>
</TD></TR></TABLE></CENTER>
<P>Every unit, be it segmental level or not, may contain a character. The TSR,
as generated by the text parser, contains the appropriate punctuation
at suprasegmental levels (that is, levels except the phone level):
spaces at the word level, commas at the
intonational unit level, periods, question marks and such will
become the contents of a sentence (terminated utterance) level.
Some suprasegmental units will have no content, because they have
been delimited only implicitly; for example, a colon-final word
has been delimited by a comma, but the comma is actually a colon
level symbol: the last word will have no content.  This content
may be modified by the rules and actually, it often is.  This allows
marking up a unit for a later use (changing its content into an
arbitrary character, such as a digit or anything else, then applying
some rules only within units having this contents using a
<A HREF="#inside-rule">rule of type inside</A>.)
<P>
<H2><A NAME="ss2.2">2.2 Rule file syntax overview</A>
</H2>

<P>
<P>The rules are applied sequentially, unless stated otherwise.
Each rule operates units of a certain level within a unit
of some other level; for instance, a rule may assimilate
phones within a word, another rule may change the syllabic
prosody within a colon.  The smaller units being manipulated
are called <EM>target units</EM>, the larger unit is referred
to as a <EM>scope unit</EM>; the respective levels are
called <EM>scope</EM> and <EM>target</EM>.  Each scope unit
is always processed separately (from any other scope units)
as if no other text ever existed.  For example, if the scope of some
assimilation happens to be "word", every word will have the rule 
applied in isolation and the assimilation will never apply across
the word boundary.  
<P>Any line of the rules file may contain at most one rule and
possibly some comment.
The rule begins with an operation code specifier (what to do),
followed by the parameter (one word, opcode specific), and possibly
by scope and target specification, if the defaults (usually word
and phone, respectively) are not suitable.
<P>The scope and the target can be one of the 
<A HREF="#tsr-levels">available levels of linguistic description</A> as defined
with the <CODE>unit_levels</CODE> option.  If target or even scope
for a rule is not specified, the <CODE>default_target</CODE> or
<CODE>default_scope</CODE> option value, respectively, will be used.
The typical defaults are <CODE>phone</CODE> and <CODE>word</CODE>, respectively.
<P>Every rule is evaluated within certain unit, and the scope specifies,
what kind of unit it should be.  
The meaning of the target is somewhat opcode specific,
but generally, this is the level which is affected by that rule.
See the individual rule descriptions in this section
in conjunction with the real world rule files for exact interpretation
of the target level.
<P>The code, scope and target identifier is not case sensitive, but the parameter
usually is.
<P>
<P>
<H2><A NAME="ss2.3">2.3 Using comments and the <CODE>&commat;include</CODE> directive</A>
</H2>

<P>
<P>Any text starting with a semicolon or <CODE>#</CODE> not in the middle of a word up to the
end of the line is a comment.  It will be properly ignored.  If a line
doesn't contain anything except whitespace and/or comment, it is also
ignored.  The <CODE>&commat;include</CODE> directive can be used to nest the rule
files.  The same rules apply within <CODE>.ini</CODE> files; for more
details, see 
<A HREF="epos-3.html#include-directive">the &commat;include directive in configuration files</A>.
<P>
<H2><A NAME="ss2.4">2.4 Variables (macros)</A>
</H2>

<P>
<P>A line, which doesn't contain a rule, may contain a <EM>macro definition</EM> instead.
It is specified as <CODE>identifier = replacement</CODE>, for example,
<BLOCKQUOTE><CODE>
<PRE>
$vowel = aeiouy
</PRE>
</CODE></BLOCKQUOTE>

Alternatively, the keyword <CODE>external</CODE> may follow an identifier instead of
the equality sign and the replacement:
<BLOCKQUOTE><CODE>
<PRE>
$some_pathname  external
</PRE>
</CODE></BLOCKQUOTE>
<P>Here the identifier is assigned the value of its corresponding
configuration parameter (for the current voice or current language if possible).
<P>The macros will get expanded anywhere where they occur except for their own
point of definition.  Therefore, <CODE>$vowel  $short$long</CODE> will be a valid macro
definition, provided that <CODE>$short</CODE> and <CODE>$long</CODE> have already been defined.  The
expansion is performed at the definition time and it is not iterated, because
the replacement is not expected to contain the dollar sign.
<P>Macros can later be redefined if you wish and they can be local to a block
of rules as described below.
<P>If there be any uncertainty concerning the exact length of the identifier,
you can use braces to embrace it: <CODE>${name}</CODE> is usually equal to <CODE>$name</CODE>, but
<CODE>$nameaeiou</CODE> is not equal to <CODE>${name}aeiou</CODE>.  It is also possible to use
a colon or an ampersand an a delimiter: <CODE>$name&amp;aeiou</CODE>.
<P>For an abundance of examples see existing rule files.
<P>
<P>
<P>
<P>
<H2><A NAME="dictionary"></A> <A NAME="ss2.5">2.5 Dictionary-oriented rules </A>
</H2>

<P>
<P>The rule types described in this subsection operate in some way
on a list of words (or other strings), which can range from a few items
up to machine-generated megabytes of data.  These strings are usually listed
in a separate file, while the parameter of such a rule is the file name.
Alternatively, the strings can be quoted inside the rule file, especially
if only a few ones are listed.  Such a collection of strings
is called a <EM>dictionary</EM> and obeys the same format for any rule type
which needs external data.
<P>The dictionary consists of multiple lines, each of which contains a single
dictionary item.  An item consists of two whitespace separated words,
the former being the item itself, the latter being some string associated with
the item.  Often, the second string is used to replace every occurrence of the
first string in the text being processed.  That's why the strings are called
<EM>replacee</EM> and <EM>replacer</EM>, respectively.  The order of dictionary items
is not significant. 
<BLOCKQUOTE> We use adaptive hash tables -- and balanced
AVL trees for collisions 
-- for representation of the dictionary in memory to achieve instant lookups of
any item, even in a huge dictionary.</BLOCKQUOTE>
<P>The replacee cannot contain whitespace (unless escaped with a backslash),
but the replacer can.  That is, if more than two words are found on a line,
the first one becomes replacee and the rest of the line, except for
post-replacee and trailing whitespace, becomes the replacer.  However, some
rule types may not allow multiple word replacers.
<P>In addition to or instead of a dictionary item, a dictionary line may
contain whitespace and comments.  The comment begins with a semicolon 
or hash mark, which is preceded with whitespace or located at the
beginning of line, and lasts up to the end of line.
A preceding backslash can be used to escape special characters (to interpret
them literally).
<P>Instead of a file name reference, it is possible to quote the contents
of the dictionary directly; this is done by encapsulating the contents
in double quotes.  Dictionary items are whitespace-separated, the replacer
and replacee are separated with a comma.
<P>
<H3>Type <CODE>subst</CODE></H3>

<P>
<P>Substring substitution.  The replacers replace every occurrence
of their respective replacees; longer matches are matched first; the
process is iterated until no replacee occurs in the string.  It is required
either to have a <CODE>phone</CODE> target, or to keep all the replacers
and replacees of the same length, because it is not obvious how to handle the
children of the units affected.
<P>Any replacer may begin with a ^ or end with a $. That forces
the substring being replaced to be at the beginning or the end
of the scope unit, respectively.
<P>The replacer should not contain units of the scope level or higher.
Unless the <CODE>paranoid</CODE> option is set, this is tolerated, but the
replacer is truncated at the first such character.
<P>Infinitely looping substitutions are currently reported as an error
condition.
<P>
<H3>Type <CODE>prep</CODE></H3>

<P>
<P>Preposition.  If the scope unit is identical to some replacee,
it gets replaced with its respective replacer and merged to its right-hand
neighbor.  If there is no such neighbor, nothing happens.  Again, the target
must currently be <CODE>phone</CODE> or all the replacers of sizes corresponding
to their respective replacees.
<P>
<H3>Type <CODE>postp</CODE></H3>

<P>
<P>Postposition.  See type <CODE>prep</CODE>, but the resultant unit is merged to its
left-hand neighbor.
<P>
<H3>Type <CODE>prosody</CODE></H3>

<P>
<P>This rule type is a prosody modeling rule which uses a dictionary
of prosodic adjustments to be applied.  
<A HREF="#prosody-rule">More details below</A>.
<P>
<P>
<H3>Type <CODE>diphones</CODE></H3>

<P>
<P>Setup the diphone layer below the phone layer.
The parameter names a file, which contains
phone to diphone mappings, again in the dictionary format
The replacees represent three character
diphone identifiers, the replacers are the respective diphone
numbers (decimal).
It is possible, and indeed typical to include multiple identifiers
for the same diphone number.
<P>The middle character denotes the phone the resulting diphone will
be assigned to.  The left hand and right hand characters may either
be a question mark, or they may specify the right hand and/or left
hand neighbors to match a specific character.  The question mark is
therefore a kind of wildcard.
<P>If both fully specified and partly specified diphones exist for
a given triplet of phones, they will be placed from left to right
in this order: <CODE>lt?, ?t?, ?tr, ltr</CODE>.
<P>A sentence may contain these diphones with the Czech diphone inventory
by Tomas Dubeda:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    p       l       o       u       t       e       f
  0p?   pl? ?lo   ?o? ou?  ?u?    ut? ?te  ?e?    ef? ?f0
</PRE>
</CODE></BLOCKQUOTE>
<P>or, with the traditional Czech diphone inventory:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    p       l       o       u       t       e       f
 0p? ?pl  pl? ?lo   ?o? ou?  ?u?    ut? ?te  ?e?    ef? ?f0
</PRE>
</CODE></BLOCKQUOTE>
<P>(In this second example, for instance the diphones <CODE>?pl</CODE>
and <CODE>?pt</CODE> would actually share the diphone number and
would correspond to the <CODE>p-any consonant</CODE> diphone.)   
<P>There are more possibilities for representing a diphone
inventory; it is necessary to decide for the major diphone
types, whether they should live in their initial or
final sound.  That is unfortunate, but it is the way it is.
Punctuation never plays a role of segments in Epos, and
the same is true here.
<P>It is possible to repeat a diphone a few times.  This effect
can be controlled by adding 10000 times the number of extra
repetitions to the diphone number.  Therefore, 
<BLOCKQUOTE><CODE>
<PRE>
?e?     20241
</PRE>
</CODE></BLOCKQUOTE>

generates three identical diphones number 241 for the stationary
part of the specified vowel.
<P>
<H3>Type <CODE>with</CODE></H3>

<P>
<P>This is actually a conditional rule, though it also uses
a dictionary.  It applies an arbitrary rule upon the units
(words) listed in the dictionary.  
<A HREF="#with-rule">More details below</A>.
<P>
<H2><A NAME="ss2.6">2.6 Contentual rules</A>
</H2>

<P>
<P>The contentual rules manipulate unit contents.  That is, they're suitable
for implementation of more regular letter-to-sound rules, character replacement
and other transformations.  They are a magnitude faster than e.g. the more
general <CODE>subst</CODE> rule, so they should be used whenever possible.
<P>
<H3>Type <CODE>regress</CODE></H3>

<P>
<P>Assimilation, elision or other mutation of phones or other units
depending on their immediate environment.  The parameter is of the form
<CODE>o&gt;n(l_r)</CODE>, where o,n,l,r are arbitrary strings.  The semantic is "change tokens
in <CODE>o</CODE> to their corresponding tokens in <CODE>n</CODE>
whenever the left neighbor is in <CODE>l</CODE>
and right one is in <CODE>r</CODE>".  The first two strings should therefore either be of
equal length, or <CODE>n</CODE> should be a single character, with the obvious
interpretations of "corresponding".
<P>The zero character (<CODE>0</CODE>0) may be included in any of the strings; it means
"no element", and it can be used to insert new units, delete the old ones,
and to limit the change to the beginning or the end of the scope unit,
respectively.  On the other hand, if the contents of some unit is literal <CODE>0</CODE>
before the application of this rule, it will stay untouched.  Use e.g.
<CODE>regex</CODE> or <CODE>subst</CODE> rules to handle this case properly.
<P>Examples:   
<BLOCKQUOTE><CODE>
<PRE>
        regress  0>'(0_aeiou)  word  phone
</PRE>
</CODE></BLOCKQUOTE>

inserts the apostrophe before the vowels listed at the beginning of a word.
<BLOCKQUOTE><CODE>
<PRE>
        regress  $voiceless>$voiced(!_$voiced)  word  phone
</PRE>
</CODE></BLOCKQUOTE>

assimilates voiceless consonants to their voiced counterparts (assuming
<CODE>$voiced</CODE> and <CODE>$voiceless</CODE> have been defined previously), when they're followed
by a voiced consonant.  The change proceeds from the right to the left,
therefore <CODE>ppb</CODE> will change to <CODE>bbb</CODE>.  See 
<A HREF="#except">below</A>
for the explanation of the exclamation mark (here: "everywhere").
<P>
<H3>Type <CODE>progress</CODE></H3>

<P>
<P>As above, but the change proceeds from left to right.  In the second
example for the <CODE>regress</CODE> rule, the result would be <CODE>pbb</CODE>
if <CODE>progress</CODE> was employed.
<P>
<H2><A NAME="ss2.7">2.7 Structural rules</A>
</H2>

<P>
<P>The structural rules can be used to restructuralize the text.  They usually interact
with multiple levels of description simultaneously.
<P>
<H3>Type <CODE>raise</CODE></H3>

<P>
<P>Move a unit to another level of description, e.g. when a segment
level unit should directly affect the prosody.  The parameter is of the form
<CODE>from:to</CODE> (<CODE>from</CODE> and <CODE>to</CODE> are arbitrary strings,
they can employ the "except" operator (exclamation mark).  The tokens
in <CODE>from</CODE>, if found at the target
level, are copied to the scope level, if the original scope token is listed
in <CODE>to</CODE>.  It is also possible to omit the colon and the <CODE>to</CODE> string; the default
interpretation is "everywhere".
<P>
<H3>Type <CODE>syll</CODE></H3>

<P>
<P>Roughly speaking, this rule type can be used to split words to
syllables according to the theory of sonority, i.e. at the least sonorous
phones.  More generally, it could be used to do any sort of inserting unit
boundaries depending on local values of a simple metric.
<P>The parameter is an ordering of the target units (typically, phones).
<P>Example:
<BLOCKQUOTE><CODE>
<PRE>
        syll  0&lt;ptkf&lt;bdgv&lt;mnN&lt;lry&lt;aeiou"  syll  phone
</PRE>
</CODE></BLOCKQUOTE>

inserts the following (and other) syllable boundaries:
<BLOCKQUOTE><CODE>
<PRE>
  a|pa  ap|pa  ap|ppppa  arp|pa  ar|pra  a|pr|pa
</PRE>
</CODE></BLOCKQUOTE>
<P>Tokens not listed are considered least sonorous, order of tokens within
the same sonority group (see the example) is irrelevant.
<P>(It is possible (using the <CODE>suppress_side_syll</CODE> and
<CODE>limit_side_syll</CODE> options in conjunction) to forbid
the formation of a unit with an insufficiently sonorous
element at its first position.  This crude feature allows
us to avoid the unwanted "side syllables" in Czech and is
off by default.  A language independent solution is not
known, especially because the authors are not certain
about similar phenomena in other languages.  Please contact
us if you can comment on syllabification irregularities
in natural languages.  We'll be happy to replace this
"feature" with something generic.   See the source
(<CODE>unit::syllabify</CODE>) for any other details.)
<P>
<H2><A NAME="prosody"></A> <A NAME="ss2.8">2.8 Prosody modeling rules </A>
</H2>

<P>
<P>The utterance prosody is modeled in Epos by assigning
values for the following prosodic quantities of individual text
structure units (possibly at multiple levels of description):
<P>
<UL>
<LI> pitch (fundamental frequency)</LI>
<LI> volume (intensity) and</LI>
<LI> duration (time factor)</LI>
</UL>
<P>Currently, these are values per cent, 100 being the neutral
value.  
<BLOCKQUOTE> Epos doesn't currently provide sets
of diphone inventories for multiple pitch ranges, therefore
extreme values, such as 15 or 1500 may sound very unnatural.</BLOCKQUOTE>
  The prosody adjustments at different levels
sum up for the actual values assigned to the generated
diphones.  For example, a phone with the frequency (pitch)
value of 130 in a word with the value of 120 will contain
diphones (after the <CODE>diphones</CODE> rule is applied) with
frequency of 150.  Alternatively, it is possible to multiply
the values for pitch, volume and duration instead, by setting the
<CODE>pros_eff_multiply_f</CODE>, <CODE>pros_eff_multiply_i</CODE> and
<CODE>pros_eff_multiply_t</CODE> options, respectively.
It is also possible to change the neutral value of 100
to a different base value with the <CODE>f_neutral</CODE>, <CODE>i_neutral</CODE>
and <CODE>t_neutral</CODE> options.
<P>
<H3><A NAME="contour-rule"></A> Type <CODE>contour</CODE> </H3>

<P>
<P>This rule assigns a specified prosody contour to units at some level
of description within a unit which consists of them.  For example,
the rule can be used to assign pitch contours to stress units;
individual values will probably be assigned to syllables.
<P>The parameter describes a single prosody contour.  The first letter
denotes the prosodic quantity (frequency, intensity or duration)
to be specified; the second is a slash; the adjustments follow
as colon-separated decimal integers.  For an example,
<BLOCKQUOTE><CODE>
<PRE>
        contour   f/+2:+0:-2   word   syll
</PRE>
</CODE></BLOCKQUOTE>

assigns a falling pitch contour to a trisyllabic word.  The number
of syllables in a word, or, more generally, of the target units
in a scope unit, must match the number of adjustments specified
in a <CODE>contour</CODE> rule, otherwise an error occurs; consider
the 
<A HREF="#counters">length-based selection of rules</A>
to ensure that.  As an exception to that, it is possible
to specify padding in the contour.  At most one
adjustment may be immediately followed by an asterisk.  This
adjustment will be used for zero or more consecutive target
units as necessary to stretch the contour over the scope unit.
<P>
<P>
<H3><A NAME="prosody-rule"></A> Type <CODE>prosody</CODE> </H3>

<P>
<P>Individual prosodic feature generation.  (See also
<A HREF="#contour-rule">the contour rule</A> for assigning
whole contours more conveniently.)
<P>Typically, there will be many instances of this rule in the rules
file, each of which using a different configuration file for
different purpose (e.g. one may handle word stress, another
one sentence-final melody of wh- questions, another one semantic
emphasis corresponding to an exclamation mark).  The parameter
of a PROSODY rule is the name of a file formatted as a dictionary
(see 
<A HREF="#dictionary">dictionary-oriented rules</A>)
and is further specified here.
<P>Each prosodic adjustment occupies one line; it affects exactly one
of frequency, intensity and duration (T, I, or F, respectively)
of units positioned among others as specified.  Their ordering 
is insignificant, because each of them affects different
units or a different quantity of them.
<P>The structure of an adjustment is very simple, so let's just
pick an example: <CODE>i/3:4   -20</CODE>.  The first letter must be one
of T, I, F and specifies the quantity that may be adjusted;
the first number specified denotes the position within a unit 
whose length is to be equal to the second number: here, the
rule applies at every third syllable of every tetrasyllable, 
provided that the target of the rule is syllable, while
the scope is word (this is specified in the rules file as 
usual, not in the prosody file).  The last number, separated 
by whitespace, is the intensity adjustment to be added 
everywhere this specification applies.  It is an integer value.
<P>It is also possible to have an adjustment applied for any
length of the scope unit (in the example above, for words
of any number of syllables.  To do this, use "*" as the
second number of the adjustment.  Also, it may make sense
to count the target unit starting at the end of the scope
unit; in this case append the word "last" to the first number.
An example could be <CODE>f/1last:*  -30</CODE>, or "drop the pitch by 30
for last syllables of every word".  Consequently, at most three
distinct rules may affect a unit; if that happens, only one is
chosen -- the more specific one, or, if both contain the
asterisk, the one counting from the beginning is chosen.
An example, in order of decreasing precedence:
<P>
<BLOCKQUOTE><CODE>
<PRE>
   t/1:2     +30
   t/1:*     +20
   t/2last:*  +5
</PRE>
</CODE></BLOCKQUOTE>
<P>You can therefore override general adjustments with exceptions
for some lengths which have to be handled separately.
<P>If multiple prosodic rules (using their own files) supply
adjustments for a certain unit, the adjustments are summed.
<P>It is important to understand the difference between
e.g. a syllable and its phones: the syllable can have an entirely
different prosodic value than its phones; for every given diphone,
the value for any prosodic quantity is obtained by totalling
the values for all of higher levels units it is contained in.
This independence of levels of description might theoretically
be useful for modeling tone languages.
<P>
<H3>Type <CODE>smooth</CODE></H3>

<P>
<P>Smoothing out of one of the F,I,T quantities.  The parameter is
<BLOCKQUOTE><CODE>
<PRE>
  quantity/left_weights/base_weight\right_weights
</PRE>
</CODE></BLOCKQUOTE>

where the <CODE>left_weights</CODE>,
if there are multiple ones, shall be slash separated, the <CODE>right_weights</CODE> shall
be backslash separated.  The new value of the quantity specified for any
target is computed as a weighted average of the values for the surrounding
units at the same level.  If the target is too near to the scope boundary
to have enough neighbors in some direction, the value for the last unit
in that direction instead.
<P>Example:
<BLOCKQUOTE><CODE>
<PRE>
        smooth  i/10/20/40\20\10  word  syll
</PRE>
</CODE></BLOCKQUOTE>

applied to the second word <CODE>un-ne-ce-ssa-ry</CODE> will adjust intensity values
for all of the syllables.  E.g. the second syllable will be computed as
0.3 x i("<CODE>un</CODE>") + 0.4 x i("<CODE>ne</CODE>") + 0.2 x i("<CODE>ce</CODE>") + 0.1 x i("<CODE>ssa</CODE>")
<P>The computations for different units do not interfere.  The weights can
also be specified as negative quantities and/or as sums of more values.
This permits linear parameterization of the rules.
<P>The <CODE>smooth</CODE> rule has also an unavoidable side effect. If (some of)
the prosodic adjustments are assigned at the word level, for example, and smoothing
should take place at the syllable level, it is first necessary to move
the prosodic information down to the syllable level. It is done by adding
the quantity found at the word level to every contained syllable and by
removing it from the word level at all.  The <CODE>unit::project</CODE> method
is responsible for that; it is called before the actual smoothing.
Prosodic adjustments existing at lower levels than is the one being smoothened
are ignored by the <CODE>smooth</CODE> rule.
<P>
<H2><A NAME="composites"></A> <A NAME="ss2.9">2.9 Composite rules </A>
</H2>

<P>
<P>Multiple rules are occasionally necessary where there are syntactical
placeholders for a single rule only.  Or, several rules have to be
grouped in a certain way -- for example, when one rule has to be chosen
nondeterministically out of a set of rules.  To satisfy these needs, Epos
rules include three types of composite rules with different semantics.
A composite rule is syntactically treated a single rule for any purpose.
<P>
<H3>Blocks of rules</H3>

<P>
<P>A block is a sequence of rules enclosed within braces ("<CODE>{</CODE>" and "<CODE>}</CODE>").
Both the opening and the closing brace follow the rule syntax, but
they take no parameters except for an optional scope specification.
The block is treated as a single rule, which is useful with conditional
rules like
<P>
<BLOCKQUOTE><CODE>
<PRE>
if   condition
{
        do   this
        do   that
}
</PRE>
</CODE></BLOCKQUOTE>
<P>The rules are applied sequentially, as you would expect, for every
unit of the proper size as given by the scope of the opening brace.
This means that every word (if the scope is <CODE>word</CODE>) is processed
separately throughout all the rules in the block.  This involves
some splitting of execution on entering the block.  By default, no
such splitting is done and the block inherits its scope from its
master rule (a conditional rule, a block it is encapsulated in,
or the global implicit block which covers all the rules altogether).
Consequently, the scope of any enclosed rule may not be larger
than the scope of the block.
<P>Any macros defined in the block are local to the block.  The semantic
details are C-like and are by no means important.
<P>
<P>
<H3>Choices of rules</H3>

<P>
<P>A choice is a sequence of rules enclosed within brackets ("<CODE>[</CODE>" and "<CODE>]</CODE>").
Both the opening and the closing bracket follow the rule syntax, but
they take no parameters except for possible scope specification.
The choice is treated as a single rule.
<P>Whenever the choice is applied, one of its subordinate rules is chosen
nondeterministically for every unit of the proper size as given by the
scope of the opening brace, and only this rule is applied.
<P>Generally, choices behave like blocks; the main difference is that with
blocks, all of the rules are applied, whereas with choices, exactly one
of them gets applied (possibly different rules for different pieces of
the text processed).
<P>Empty choices (with no rules within) are not tolerated, contrary
to empty blocks.
<P>
<P>
<H3><A NAME="counters"></A> Length-based selection of rules </H3>

<P>
<P>A (length-based) switch is a sequence of rules enclosed within angle
brackets ("<CODE>&lt;</CODE>" and "<CODE>&gt;</CODE>").  Both the opening and the closing bracket follow
the rule syntax, but they take no parameters except for possible scope
and target specification.  The switch is treated as a single rule.
<P>Whenever the switch is applied to a scope unit, target units contained
within are counted.  If <CODE>n</CODE> units are found, the <CODE>n</CODE>-th rule in sequence of
the subordinate rule is applied. 
<P>If there is less than <CODE>n</CODE> rules available, the last one will be used.
You can avoid this behavior by specifying "nothing" after the last rule.
<P>
<P>
<H3>Repeated rules and choice probabilities</H3>

<P>
<P>Write "<CODE>3x</CODE>" before a rule to repeat it three times (in a block)
or to make it three times more probable (in a choice):
<P>
<BLOCKQUOTE><CODE>
<PRE>
[
        3x prosody              typical.dic
           prosody              variant.dic
]
</PRE>
</CODE></BLOCKQUOTE>
<P>(The first alternative now has 75% of being chosen, while
the other one is left for the remaining 25%.)
<P>The repeat count must be a positive integer.  You can not use
this feature just after conditional rules, because repeated
rules are not counted as a single rule for syntactic purposes:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        if  $something
                2x   regress   0>x(!_!)   #...wrong!
</PRE>
</CODE></BLOCKQUOTE>
<P>You should rewrite this to
<P>
<BLOCKQUOTE><CODE>
<PRE>
        if  $something
        {
                2x   regress   0>x(!_!)
        }
</PRE>
</CODE></BLOCKQUOTE>
<P>Huge integers (like one million) are disallowed.  This is because
the current implementation needs a few bytes of memory (one pointer)
per every repetition.
<P>
<P>
<P>
<H2><A NAME="ss2.10">2.10 Conditional rules</A>
</H2>

<P>
<P>The conditional rules execute the following rule if and only if
a condition is met.  The condition is specified as the parameter,
the following (conditioned) rule is given on a separate line
(or lines, if a 
<A HREF="#composites">composite rule</A>
follows).  (Comments, whitespace and empty lines may intervene as
usual.) It is not syntactically necessary to indent the conditioned
rules with whitespace, but it is strongly recommended for readability.
<P>
<H3><A NAME="inside-rule"></A> Type <CODE>inside</CODE> </H3>

<P>
<P>Apply a rule or a block of rules within certain units only.
The parameter is a list of values at the scope level, wherein the
following rule should be applied; the "except" operator may be used.
<P>Every unit (a sentence, for example), which fulfills the criterion,
is processed separately, therefore the scope of the following rule may
be at most that of the <CODE>inside</CODE> rule itself.
<P>
<H3><A NAME="with-rule"></A> Type <CODE>with</CODE> </H3>

<P>
<P>Apply a rule or a block of rules for a list of units.
In contrast with the preceding rule type, this refers not only
to the token at the scope level (such as space), but to the whole
structure (such as the string of phones delimited by the space).
<P>The parameter is a filename; the file should list the strings
subject to the following rule, such as special words.
<P>
<H3>Type <CODE>if</CODE></H3>

<P>
<P>Apply a rule or a block of rules only if a condition (given
by the parameter) is met.  The condition must currently be specified
as a boolean voice configuration option (possibly a soft option)
or its negation (i.e. prefixed with an exclamation mark).
<P>Example:
<BLOCKQUOTE><CODE>
<PRE>
if   !colloquial
{
        ...
}
</PRE>
</CODE></BLOCKQUOTE>
<P>The rules within the block will be applied only if the colloquial
option is <EM>not</EM> set.
<P>This <CODE>if</CODE> rule inherits its scope from its parent rule
if not specified explicitly.
<P>Again, the scope of a subordinate rule may not be larger than that of
the <CODE>if</CODE> rule itself.
<P>
<P>
<H2><A NAME="ss2.11">2.11 Special rules</A>
</H2>

<H3>Type <CODE>regex</CODE></H3>

<P>
<P>Regular expression substitution.  The parameter is of the form
<CODE>/regular_expression/replacement/</CODE>.  This rule type is similar to <CODE>subst</CODE>,
but it is more powerful and more arcane; it is not intended for end
wizards.  Skip it.
<P>For a regular expressions' overview  try <CODE>man grep</CODE>.  Note a difference:
in "regular" regular expressions, parentheses match themselves, while
the open group and close group operators are <CODE>\(</CODE> and <CODE>\)</CODE>, respectively.
As we use groups heavily and next to none real parentheses, we decided
to do it the other way round.
<P>The replacement may contain escape sequences referring to the match of
the <CODE>n</CODE>-th group within the regular expression: <CODE>\1</CODE> to <CODE>\9</CODE>.
<CODE>\0</CODE> represents the entire match, but this is probably unusable under the
current design, as this would cause an infinite substitution loop.
<P>In order to use this type of rule, you need to have the <CODE>rx</CODE> or <CODE>regex</CODE>
library already installed and have <CODE>WANT_REGEX</CODE> enabled in <CODE>common.h</CODE>.
This is because we don't actually implement the regex parsing stuff; we leave it
to your OS libraries.  In case you don't have such libraries installed, we use
the glibc implementation (<CODE>rx.c</CODE> in the distribution).
<P>
<H3><A NAME="debug-rule"></A> Type <CODE>debug</CODE> </H3>

<P>
<P>Debugging information during the application of the rules.
Scope and target are ignored, the parameter is parsed lazily.
<P>Parameter "<CODE>elem</CODE>": dump the current state of the text being processed
Parameter "<CODE>pause</CODE>": wait until keypress
<P>
<P>
<P>
<H2><A NAME="except"></A> <A NAME="ss2.12">2.12 The "except" (<CODE>!</CODE>) operator </A>
</H2>

<P>
<P>Whenever an unordered list of tokens should be specified within the parameter
to some rule (use common sense and/or individual rule descriptions above),
you can also make negative specifications, such as "all consonants except
l and r".  To do this, use the exclamation mark serving as an "except" operator:
<CODE>$consonants!lr</CODE> (The right operand is subtracted from the left one.)
If there is no left operand, say in <CODE>!x</CODE>, the semantics is "all but x".
You see that <CODE>!</CODE> alone means "everything".
<P>The operator is right-associative; <CODE>!$vowels!ou</CODE> means "all excluding vowels,
but <CODE>o</CODE> and <CODE>u</CODE> don't count as vowels just now".
<P>Let us repeat that this operator will never work for ordered lists, not even
for the <CODE>syll</CODE> rule sonority groups.
<P>
<P>
<H2><A NAME="ss2.13">2.13 Escaping special characters</A>
</H2>

<P>
<P>You can use the backslash to escape any special character including itself
anywhere in the rules or <CODE>.ini</CODE> file strings.
<CODE>\n</CODE>, <CODE>\t</CODE>, <CODE>\[</CODE> may be used
to insert a newline, tab, or escape characters, respectively.
<P>
<P>
<HR>
<A HREF="epos-3.html">Next</A>
<A HREF="epos-1.html">Previous</A>
<A HREF="epos.html#toc2">Contents</A>
</BODY>
</HTML>
