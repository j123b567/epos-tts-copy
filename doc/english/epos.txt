  The Epos Speech System
  Jirka Hanika geo@ff.cuni.cz
  6 December 1998

  User Documentation for the Epos Speech System, as distributed with
  Epos version 2.3.12.  Copyright (c) 1996-98 by Jirka Hanika. This doc-
  ument is a part of the Epos Speech System and is therefore covered by
  the General Public License (see doc/COPYING).
  ______________________________________________________________________

  Table of Contents























































  1. Introduction

  2. Rules

     2.1 Text Structure Representation overview
     2.2 Rule file syntax overview
     2.3 Using comments and the #include directive
     2.4 Variables (macros)
     2.5 Dictionary-oriented rules
        2.5.1 Type subst
        2.5.2 Type prep
        2.5.3 Type postp
        2.5.4 Type prosody
        2.5.5 Type diphones
        2.5.6 Type with
     2.6 Contentual rules
        2.6.1 Type regress
        2.6.2 Type progress
     2.7 Structural rules
        2.7.1 Type raise
        2.7.2 Type syll
     2.8 Prosody modeling rules
        2.8.1 Type contour
        2.8.2 Type prosody
        2.8.3 Type smooth
     2.9 Composite rules
        2.9.1 Blocks of rules
        2.9.2 Choices of rules
        2.9.3 Length-based selection of rules
        2.9.4 Repeated rules and choice probabilities
     2.10 Conditional rules
        2.10.1 Type inside
        2.10.2 Type with
        2.10.3 Type if
     2.11 Special rules
        2.11.1 Type regex
        2.11.2 Type debug
     2.12 The "except" (!) operator
     2.13 Escaping special characters

  3. Options

     3.1 Option classes
     3.2 Configuration files
        3.2.1 Configuration file format overview
        3.2.2 Escaping special characters
        3.2.3 Comments and the #include directive
     3.3 Command line
     3.4 Setting options in TTSCP
        3.4.1 allowed.ini file
     3.5 Semipermanent personal preferences
     3.6 Soft options
     3.7 Selected options
        3.7.1 Overall options
        3.7.2 Types of output
        3.7.3 Text output formatting
        3.7.4 Limits
        3.7.5 Language dependent configuration
        3.7.6 Voice dependent configuration
        3.7.7 Prosody generation
        3.7.8 File naming
        3.7.9 Daemon startup options
        3.7.10 Debugging options

  4. Text-To-Speech Control Protocol  (TTSCP)  (version 1)

     4.1 Data formats
        4.1.1 Plain ASCII text
        4.1.2 STML
        4.1.3 Text structure representation
        4.1.4 Sequence of diphones
        4.1.5 Waveform
     4.2 TTSCP Commands
        4.2.1 appl
        4.2.2 brk
        4.2.3 data
        4.2.4 delh
        4.2.5 done
        4.2.6 down
        4.2.7 help
        4.2.8 pass
        4.2.9 reap
        4.2.10 say
        4.2.11 set
        4.2.12 show
        4.2.13 strm
           4.2.13.1 Input and output modules
           4.2.13.2 Processing modules
           4.2.13.3 Explicit data type specifications
        4.2.14 trans
        4.2.15 user
     4.3 response codes
        4.3.1 response classes
        4.3.2 response subclasses
        4.3.3 currently defined messages

  5. Source Code Documentation

     5.1 Design goals
     5.2 Isolated classes
        5.2.1 Class simpleparser
        5.2.2 Class unit
        5.2.3 Class text
        5.2.4 Class file
        5.2.5 Class hash
        5.2.6 Class rules
     5.3 Class hierarchies
        5.3.1 Class rule
        5.3.2 Class agent
     5.4 More information


  ______________________________________________________________________

  11..  IInnttrroodduuccttiioonn


  In the early nineties, the Institute of Phonetics, Faculty of Arts,
  Charles University, Prague, and the Institute of Radio-Engineering and
  Electronics, Academy of Sciences, Prague, had managed to assemble a
  complete TTS implementation for the Czech and Slovak languages, using
  a linear prediction based diphone synthesis.  This TTS engine then
  served as a base for further research in speech synthesis, until the
  source became too large and complicated to be easily modified, ported
  to new hardware or operating system, or to be well understood by
  anybody except the authors.  By the end of 1995, when a need for
  testing some new prosody modelling hypotheses had arisen, these
  limitations were slowly becoming a major burden. A new implementation
  of part of the system was eventually written from scratch (starting in
  1996) and it is still expanding, integrating the original results with
  numerous recent improvements. It has been baptized Epos Speech System
  in 1998.
  Our primary design goal is to allow the user the ultimate control over
  the TTS processing. We avoid hard-wired constants; we use
  configuration options instead, with sensible default values.  Most of
  the language-dependent processing is driven by a _r_u_l_e_s _f_i_l_e, a text
  file using an intuitive and well-documented syntax. A rules file lists
  the rules to be applied on a written text structure representation to
  yield a corresponding spoken text structure representation (in fact it
  could be the other way round in principle, but somehow no one seems to
  need that).  Some aspects of user-definable behavior don't fit into
  the concept of a rules file, and are therefore settable with various
  options in conventional configuration files.  Finally, many other
  external files can be referenced either by the rules file, or a
  configuration file, such as diphone inventories or dictionaries.

  Most of these files have to be processed before any actual TTS
  processing has finished. That's why Epos is implemented as a
  background process; it reserves a TCP/IP port for any communication
  with client applications.  Epos uses a custom, quite generic protocol
  for TTS data flow control, called TTSCP.  The Epos daemon binary is
  called epos; a simple client named say has been provided.  This client
  instructs the daemon to process the text sent by the client and to
  write the resulting waveform into /dev/dsp, which is hopefully a sound
  card device.

  Epos currently supports two main speech generation algorithms.  The
  first one is a diphone concatenation in the time domain, originally
  contributed by Zdenek Kadlec, Masaryk University, Brno.  This
  algorithm, including a low quality diphone inventory, is available as
  part of Epos subject to GPL.  The second one is a linear prediction
  coding speech synthesis written by E. Vichova, which actually gives
  very good results, but is not freely available (existing commercial
  applications prohibit this). You can however use a virtual speech
  synthesis to synthesize your own texts using the linear prediction
  algorithm, if you are connected to the Internet. (Your text is partly
  processed and sent to our server.  Then the generated speech signal is
  sent back to you.) We are constantly working on improving especially
  the freely distributable synthesis.

  The name Epos is not an acronym.  It is Greek for...um, go have a look
  yourself.

  This section still has to be (re)written by somebody. At present, try
  to look at
    <http://epos.ure.cas.cz> for additional introductory information or
  ask the authors by email.

  Meanwhile, tell us what kind of introductory information you would
  like to see here.  The documentation is provided for you and we need
  your feedback.



  22..  RRuulleess


  In Epos, nearly all of the TTS processing is controlled by a rule
  file; there is one rule file per language and it usually has the .rul
  suffix.  The rule file for the German language, for instance, resides
  by default in lng/german/german.rul. The rules may also slightly vary
  for the individual voices using the ``soft options''.


  22..11..  TTeexxtt SSttrruuccttuurree RReepprreesseennttaattiioonn oovveerrvviieeww



  The text being processed by Epos is internally stored in a format
  suitable for the application of transformational rules.  Every
  phonetic unit (or an approximation of it) is represented by a single
  node in the structure. The nodes are organized into layers
  corresponding to linguistic levels of description, such that a unit of
  level n can list its immediate constituents, that is units of level
  n-1. Every layer also has a symbolic name, which is used to refer to
  it in the rules.

  The number and symbolic names of individual levels can be specified on
  compile time and they're currently these:


  |            |                              |                        |
  |_____________|_______________________________|_________________________|_
  |Level name  |  written TSR semantics       |  spoken TSR semantics  |
  |_____________|_______________________________|_________________________|_
  |text        |     the whole text           |  the whole text        |
  |sent        |     sentence construction    |  terminated utterance  |
  |colon       |     sentence/clause/colon    |  intonational unit     |
  |word        |     word                     |  stress unit           |
  |syll        |     word                     |  syllable              |
  |phone       |     letter                   |  sound                 |
  |diphone     |                              |  diphone               |
  |_____________|_______________________________|_________________________|_


              Available Text Structure Representation layers

  Every unit, be it segmental level or not, may contain a character. The
  TSR, as generated by the text parser, contains the appropriate
  punctuation at suprasegmental levels (that is, levels except the phone
  level): spaces at the word level, commas at the intonational unit
  level, periods, question marks and such will become the contents of a
  sentence (terminated utterance) level.  Some suprasegmental units will
  have no content, because they have been delimited only implicitly; for
  example, a colon-final word has been delimited by a comma, but the
  comma is actually a colon level symbol: the last word will have no
  content.  This content may be modified by the rules and actually, it
  often is.  This allows marking up a unit for a later use (changing its
  content into an arbitrary character, such as a digit or anything else,
  then applying some rules only within units having this contents using
  a ``rule of type inside''.)


  22..22..  RRuullee ffiillee ssyynnttaaxx oovveerrvviieeww


  The rules are applied sequentially, unless stated otherwise.  Each
  rule operates units of a certain level within a unit of some other
  level; for instance, a rule may assimilate phones within a word,
  another rule may change the syllabic prosody within a colon.  The
  smaller units being manipulated are called _t_a_r_g_e_t _u_n_i_t_s, the larger
  unit is referred to as a _s_c_o_p_e _u_n_i_t; the respective levels are called
  _s_c_o_p_e and _t_a_r_g_e_t.  Each scope unit is always processed separately
  (from any other scope units) as if no other text ever existed.  For
  example, if the scope of some assimilation happens to be "word", every
  word will have the rule applied in isolation and the assimilation will
  never apply across the word boundary.

  Any line of the rules file may contain at most one rule and possibly
  some comment.  The rule begins with an operation code specifier (what
  to do), followed by the parameter (one word, opcode specific), and
  possibly by scope and target specification, if the defaults (usually
  word and phone, respectively) are not suitable.

  The scope and the target can be one of the ``available levels of
  linguistic description''

  "diphone", "phone", "syll", "word", "colon", "sent", and "text".

  Other levels of description may be added later.  Every rule is
  evaluated within certain unit, and the scope specifies, what kind of
  unit it should be.  The meaning of the target is somewhat opcode
  specific, but generally, this is the level which is affected by that
  rule.  See the individual rule descriptions in this section in
  conjunction with the real world rule files for exact interpretation of
  the target level.

  The code, scope and target identifier is not case sensitive, but the
  parameter usually is.



  22..33..  UUssiinngg ccoommmmeennttss aanndd tthhee ##iinncclluuddee ddiirreeccttiivvee


  Any text starting with a semicolon or # not in the middle of a word up
  to the end of the line is a comment.  It will be properly ignored.  If
  a line doesn't contain anything except whitespace and/or comment, it
  is also ignored.  The #include directive can be used to nest the rule
  files.  The same rules apply within .ini files; for more details, see
  ``the #include directive in configuration files''.


  22..44..  VVaarriiaabblleess ((mmaaccrrooss))


  A line, which doesn't contain a rule, may contain a _m_a_c_r_o _d_e_f_i_n_i_t_i_o_n
  instead.  It is specified as identifier = replacement, for example,


       $vowel = aeiouy




  Alternatively, the keyword external may follow an identifier except of
  the equality sign and the replacement:


       $some_pathname  external




  Here the identifier is assigned the value of its corresponding
  configuration parameter (for the current voice or current language if
  possible).

  The macros will get expanded anywhere where they occur except for
  their own point of definition.  Therefore, $vowel  $short$long will be
  a valid macro definition, provided that $short and $long have already
  been defined.  The expansion is performed at the definition time and
  it is not iterated, because the replacement is not expected to contain
  the dollar sign.

  Macros can later be redefined if you wish and they can be local to a
  block of rules as described below.

  If there be any uncertainty concerning the exact length of the
  identifier, you can use braces to embrace it: ${name} is usually equal
  to $name, but $nameaeiou is not equal to ${name}aeiou.  It is also
  possible to use a colon or an ampersand an a delimiter: $name&aeiou.

  For an abundance of examples see existing rule files.





  22..55..  DDiiccttiioonnaarryy--oorriieenntteedd rruulleess


  The rule types described in this subsection operate in some way on a
  list of words (or other strings), which can range from a few items up
  to machine-generated megabytes of data.  These strings are usually
  listed in a separate file, while the parameter of such a rule is the
  file name.  Alternatively, the strings can be quoted inside the rule
  file, especially if only a few ones are listed.  Such a collection of
  strings is called a _d_i_c_t_i_o_n_a_r_y and obeys the same format for any rule
  type which needs external data.

  The dictionary consists of multiple lines, each of which contains a
  single dictionary item.  An item consists of two whitespace separated
  words, the former being the item itself, the latter being some string
  associated with the item.  Often, the second string is used to replace
  every occurrence of the first string in the text being processed.
  That's why the strings are called _r_e_p_l_a_c_e_e and _r_e_p_l_a_c_e_r, respectively.
  The order of dictionary items is not significant.  (--  We use
  adaptive hash tables -- and balanced AVL trees for collisions -- for
  representation of the dictionary in memory to achieve instant lookups
  of any item, even in a huge dictionary.--)

  The replacee cannot contain whitespace (unless escaped with a
  backslash), but the replacer can.  That is, if more than two words are
  found on a line, the first one becomes replacee and the rest of the
  line, except for post-replacee and trailing whitespace, becomes the
  replacer.  However, some rule types may not allow multiple word
  replacers.

  In addition to or instead of a dictionary item, a dictionary line may
  contain whitespace and comments.  The comment begins with a semicolon
  or hash mark, which is preceded with whitespace or located at the
  beginning of line, and lasts up to the end of line.  A preceding
  backslash can be used to escape special characters (to interpret them
  literally).

  Instead of a file name reference, it is possible to quote the contents
  of the dictionary directly; this is done by encapsulating the contents
  in double quotes.  Dictionary items are whitespace-separated, the
  replacer and replacee are separated with a comma.


  22..55..11..  TTyyppee ssuubbsstt


  Substring substitution.  The replacers replace every occurrence of
  their respective replacees; longer matches are matched first; the
  process is iterated until no replacee occurs in the string.  It is
  required either to have a phone target, or to keep all the replacers
  and replacees of the same length, because it is not obvious how to
  handle the children of the units affected.

  Any replacer may begin with a ^ or end with a $. That forces the
  substring being replaced to be at the beginning or the end of the
  scope unit, respectively.

  The replacer should not contain units of the scope level or higher.
  Unless the paranoid option is set, this is tolerated, but the replacer
  is truncated at the first such character.

  Infinitely looping substitutions are currently reported as an error
  condition.


  22..55..22..  TTyyppee pprreepp


  Preposition.  If the scope unit is identical to some replacee, it gets
  replaced with its respective replacer and merged to its right-hand
  neighbor.  If there is no such neighbor, nothing happens.  Again, the
  target must currently be phone or all the replacers of sizes
  corresponding to their respective replacees.


  22..55..33..  TTyyppee ppoossttpp


  Postposition.  See type prep, but the resultant unit is merged to its
  left-hand neighbor.


  22..55..44..  TTyyppee pprroossooddyy


  This rule type is a prosody modeling rule which uses a dictionary of
  prosodic adjustments to be applied.  ``More details below''.



  22..55..55..  TTyyppee ddiipphhoonneess


  Setup the diphone layer below the phone layer.  The parameter names a
  file, which contains phone to diphone mappings, again in the
  dictionary format The replacees represent three character diphone
  identifiers, the replacers are the respective diphone numbers
  (decimal).  It is possible, and indeed typical to include multiple
  identifiers for the same diphone number.

  The middle character denotes the phone the resulting diphone will be
  assigned to.  The left hand and right hand characters may either be a
  question mark, or they may specify the right hand and/or left hand
  neighbors to match a specific character.  The question mark is
  therefore a kind of wildcard.

  If both fully specified and partly specified diphones exist for a
  given triplet of phones, they will be placed from left to right in
  this order: lt?, ?t?, ?tr, ltr.

  A sentence may contain these diphones with the Czech diphone inventory
  by Tomas Dubeda:



           p       l       o       u       t       e       f
         0p?   pl? ?lo   ?o? ou?  ?u?    ut? ?te  ?e?    ef? ?f0




  or, with the traditional Czech diphone inventory:

           p       l       o       u       t       e       f
        0p? ?pl  pl? ?lo   ?o? ou?  ?u?    ut? ?te  ?e?    ef? ?f0




  (In this second example, for instance the diphones ?pl and ?pt would
  actually share the diphone number and would correspond to the p-any
  consonant diphone.)

  There are more possibilities for representing a diphone inventory; it
  is necessary to decide for the major diphone types, whether they
  should live in their initial or final sound.  That is unfortunate, but
  it is the way it is.  Punctuation never plays a role of segments in
  Epos, and the same is true here.

  It is possible to repeat a diphone a few times.  This effect can be
  controlled by adding 10000 times the number of extra repetitions to
  the diphone number.  Therefore,


       ?e?     20241




  generates three identical diphones number 241 for the stationary part
  of the specified vowel.


  22..55..66..  TTyyppee wwiitthh


  This is actually a conditional rule, though it also uses a dictionary.
  It applies an arbitrary rule upon the units (words) listed in the
  dictionary.  ``More details below''.


  22..66..  CCoonntteennttuuaall rruulleess


  The contentual rules manipulate unit contents.  That is, they're
  suitable for implementation of more regular letter-to-sound rules,
  character replacement and other transformations.  They are a magnitude
  faster than e.g. the more general subst rule, so they should be used
  whenever possible.


  22..66..11..  TTyyppee rreeggrreessss


  Assimilation, elision or other mutation of phones or other units
  depending on their immediate environment.  The parameter is of the
  form o>n(l_r), where o,n,l,r are arbitrary strings.  The semantic is
  "change tokens in o to their corresponding tokens in n whenever the
  left neighbor is in l and right one is in r".  The first two strings
  should therefore either be of equal length, or n should be a single
  character, with the obvious interpretations of "corresponding".

  The zero character (00) may be included in any of the strings; it
  means "no element", and it can be used to insert new units, delete the
  old ones, and to limit the change to the beginning or the end of the
  scope unit, respectively.  On the other hand, if the contents of some
  unit is literal 0 before the application of this rule, it will stay
  untouched.  Use e.g.  regex or subst rules to handle this case
  properly.
  Examples:


               regress  0>'(0_aeiou)  word  phone




  inserts the apostrophe before the vowels listed at the beginning of a
  word.


               regress  $voiceless>$voiced(!_$voiced)  word  phone




  assimilates voiceless consonants to their voiced counterparts (assum-
  ing $voiced and $voiceless have been defined previously), when they're
  followed by a voiced consonant.  The change proceeds from the right to
  the left, therefore ppb will change to bbb.  See ``below'' for the
  explanation of the exclamation mark (here: "everywhere").


  22..66..22..  TTyyppee pprrooggrreessss


  As above, but the change proceeds from left to right.  In the second
  example for the regress rule, the result would be pbb if progress was
  employed.


  22..77..  SSttrruuccttuurraall rruulleess


  The structural rules can be used to restructuralize the text.  They
  usually interact with multiple levels of description simultaneously.


  22..77..11..  TTyyppee rraaiissee


  Move a unit to another level of description, e.g. when a segment level
  unit should directly affect the prosody.  The parameter is of the form
  from:to (from and to are arbitrary strings, they can employ the
  "except" operator (exclamation mark).  The tokens in from, if found at
  the target level, are copied to the scope level, if the original scope
  token is listed in to.  It is also possible to omit the colon and the
  to string; the default interpretation is "everywhere".


  22..77..22..  TTyyppee ssyyllll


  Roughly speaking, this rule type can be used to split words to
  syllables according to the theory of sonority, i.e. at the least
  sonorous phones.  More generally, it could be used to do any sort of
  inserting unit boundaries depending on local values of a simple
  metric.

  The parameter is an ordering of the target units (typically, phones).

  Example:



          syll  0<ptkf<bdgv<mnN<lry<aeiou"  syll  phone




  inserts the following (and other) syllable boundaries:


         a|pa  ap|pa  ap|ppppa  arp|pa  ar|pra  a|pr|pa




  Tokens not listed are considered least sonorous, order of tokens
  within the same sonority group (see the example) is irrelevant.

  (It is possible (using the suppress_side_syll and limit_side_syll
  options in conjunction) to forbid the formation of a unit with an
  insufficiently sonorous element at its first position.  This crude
  feature allows us to avoid the unwanted "side syllables" in Czech and
  is off by default.  A language independent solution is not known,
  especially because the authors are not certain about similar phenomena
  in other languages.  Please contact us if you can comment on
  syllabification irregularities in natural languages.  We'll be happy
  to replace this "feature" with something generic.   See the source
  (unit::syllabify) for any other details.)


  22..88..  PPrroossooddyy mmooddeelliinngg rruulleess


  The utterance prosody is modeled in Epos by assigning values for the
  following prosodic quantities of individual text structure units
  (possibly at multiple levels of description):


  +o  pitch (fundamental frequency)

  +o  volume (intensity) and

  +o  duration (time factor)

  Currently, these are values per cent, 100 being the neutral value.
  (--  Epos doesn't currently provide sets of diphone inventories for
  multiple pitch ranges, therefore extreme values, such as 15 or 1500
  may sound very unnatural.--) The prosody adjustments at different
  levels sum up for the actual values assigned to the generated
  diphones.  For example, a phone with the frequency (pitch) value of
  130 in a word with the value of 120 will contain diphones (after the
  diphones rule is applied) with frequency of 150.  Alternatively, it is
  possible to multiply the values for pitch, volume and duration
  instead, by setting the pros_eff_multiply_f, pros_eff_multiply_i and
  pros_eff_multiply_t options, respectively.  It is also possible to
  change the neutral value of 100 to a different base value with the
  f_neutral, i_neutral and t_neutral options.


  22..88..11..  TTyyppee ccoonnttoouurr


  This rule assigns a specified prosody contour to units at some level
  of description within a unit which consists of them.  For example, the
  rule can be used to assign pitch contours to stress units; individual
  values will probably be assigned to syllables.


  The parameter describes a single prosody contour.  The first letter
  denotes the prosodic quantity (frequency, intensity or duration) to be
  specified; the second is a slash; the adjustments follow as colon-
  separated decimal integers.  For an example,


               contour   f/+2:+0:-2   word   syll




  assigns a falling pitch contour to a trisyllabic word.  The number of
  syllables in a word, or, more generally, of the target units in a
  scope unit, must match the number of adjustments specified in a con-
  tour rule, otherwise an error occurs; consider the ``length-based
  selection of rules'' to ensure that.



  22..88..22..  TTyyppee pprroossooddyy


  Individual prosodic feature generation.  (See also ``the contour
  rule'' for assigning whole contours more conveniently.)

  Typically, there will be many instances of this rule in the rules
  file, each of which using a different configuration file for different
  purpose (e.g. one may handle word stress, another one sentence-final
  melody of wh- questions, another one semantic emphasis corresponding
  to an exclamation mark).  The parameter of a PROSODY rule is the name
  of a file formatted as a dictionary (see ``dictionary-oriented
  rules'') and is further specified here.

  Each prosodic adjustment occupies one line; it affects exactly one of
  frequency, intensity and duration (T, I, or F, respectively) of units
  positioned among others as specified.  Their ordering is
  insignificant, because each of them affects different units or a
  different quantity of them.

  The structure of an adjustment is very simple, so let's just pick an
  example: i/3:4   -20.  The first letter must be one of T, I, F and
  specifies the quantity that may be adjusted; the first number
  specified denotes the position within a unit whose length is to be
  equal to the second number: here, the rule applies at every third
  syllable of every tetrasyllable, provided that the target of the rule
  is syllable, while the scope is word (this is specified in the rules
  file as usual, not in the prosody file).  The last number, separated
  by whitespace, is the intensity adjustment to be added everywhere this
  specification applies.  It is an integer value.

  It is also possible to have an adjustment applied for any length of
  the scope unit (in the example above, for words of any number of
  syllables.  To do this, use "*" as the second number of the
  adjustment.  Also, it may make sense to count the target unit starting
  at the end of the scope unit; in this case append the word "last" to
  the first number.  An example could be f/1last:*  -30, or "drop the
  pitch by 30 for last syllables of every word".  Consequently, at most
  three distinct rules may affect a unit; if that happens, only one is
  chosen -- the more specific one, or, if both contain the asterisk, the
  one counting from the beginning is chosen.  An example, in order of
  decreasing precedence:





     t/1:2     +30
     t/1:*     +20
     t/2last:*  +5




  You can therefore override general adjustments with exceptions for
  some lengths which have to be handled separately.

  If multiple prosodic rules (using their own files) supply adjustments
  for a certain unit, the adjustments are summed.

  It is important to understand the difference between e.g. a syllable
  and its phones: the syllable can have an entirely different prosodic
  value than its phones; for every given diphone, the value for any
  prosodic quantity is obtained by totalling the values for all of
  higher levels units it is contained in.  This independence of levels
  of description might theoretically be useful for modeling tone
  languages.


  22..88..33..  TTyyppee ssmmooootthh


  Smoothing out of one of the F,I,T quantities.  The parameter is


         quantity/left_weights/base_weight\right_weights




  where the left_weights, if there are multiple ones, shall be slash
  separated, the right_weights shall be backslash separated.  The new
  value of the quantity specified for any target is computed as a
  weighted average of the values for the surrounding units at the same
  level.  If the target is too near to the scope boundary to have enough
  neighbors in some direction, the value for the last unit in that
  direction instead.

  Example:


               smooth  i/10/20/40\20\10  word  syll




  applied to the second word un-ne-ce-ssa-ry will adjust intensity val-
  ues for all of the syllables.  E.g. the second syllable will be com-
  puted as 0.3 x i("un") + 0.4 x i("ne") + 0.2 x i("ce") + 0.1 x
  i("ssa")

  The computations for different units do not interfere.  The weights
  can also be specified as negative quantities and/or as sums of more
  values.  This permits linear parameterization of the rules.

  The smooth rule has also an unavoidable side effect. If (some of) the
  prosodic adjustments are assigned at the word level, for example, and
  smoothing should take place at the syllable level, it is first
  necessary to move the prosodic information down to the syllable level.
  It is done by adding the quantity found at the word level to every
  contained syllable and by removing it from the word level at all.  The
  unit::project method is responsible for that; it is called before the
  actual smoothing.  Prosodic adjustments existing at lower levels than
  is the one being smoothened are ignored by the smooth rule.


  22..99..  CCoommppoossiittee rruulleess


  Multiple rules are occasionally necessary where there are syntactical
  placeholders for a single rule only.  Or, several rules have to be
  grouped in a certain way -- for example, when one rule has to be
  chosen nondeterministically out of a set of rules.  To satisfy these
  needs, Epos rules include three types of composite rules with
  different semantics.  A composite rule is syntactically treated a
  single rule for any purpose.


  22..99..11..  BBlloocckkss ooff rruulleess


  A block is a sequence of rules enclosed within braces ("{" and "}").
  Both the opening and the closing brace follow the rule syntax, but
  they take no parameters except for an optional scope specification.
  The block is treated as a single rule, which is useful with
  conditional rules like



       if   condition
       {
               do   this
               do   that
       }




  The rules are applied sequentially, as you would expect, for every
  unit of the proper size as given by the scope of the opening brace.
  This means that every word (if the scope is word) is processed
  separately throughout all the rules in the block.  This involves some
  splitting of execution on entering the block.  By default, no such
  splitting is done and the block inherits its scope from its master
  rule (a conditional rule, a block it is encapsulated in, or the global
  implicit block which covers all the rules altogether).  Consequently,
  the scope of any enclosed rule may not be larger than the scope of the
  block.

  Any macros defined in the block are local to the block.  The semantic
  details are C-like and are by no means important.



  22..99..22..  CChhooiicceess ooff rruulleess


  A choice is a sequence of rules enclosed within brackets ("[" and
  "]").  Both the opening and the closing bracket follow the rule
  syntax, but they take no parameters except for possible scope
  specification.  The choice is treated as a single rule.

  Whenever the choice is applied, one of its subordinate rules is chosen
  nondeterministically for every unit of the proper size as given by the
  scope of the opening brace, and only this rule is applied.

  Generally, choices behave like blocks; the main difference is that
  with blocks, all of the rules are applied, whereas with choices,
  exactly one of them gets applied (possibly different rules for
  different pieces of the text processed).

  Empty choices (with no rules within) are not tolerated, contrary to
  empty blocks.



  22..99..33..  LLeennggtthh--bbaasseedd sseelleeccttiioonn ooff rruulleess


  A (length-based) switch is a sequence of rules enclosed within angle
  brackets ("<" and ">").  Both the opening and the closing bracket
  follow the rule syntax, but they take no parameters except for
  possible scope and target specification.  The switch is treated as a
  single rule.

  Whenever the switch is applied to a scope unit, target units contained
  within are counted.  If n units are found, the n-th rule in sequence
  of the subordinate rule is applied.

  If there is less than n rules available, the last one will be used.
  You can avoid this behavior by specifying "nothing" after the last
  rule.



  22..99..44..  RReeppeeaatteedd rruulleess aanndd cchhooiiccee pprroobbaabbiilliittiieess


  Write "3x" before a rule to repeat it three times (in a block) or to
  make it three times more probable (in a choice):



       [
               3x prosody              typical.dic
                  prosody              variant.dic
       ]




  (The first alternative now has 75% of being chosen, while the other
  one is left for the remaining 25%.)

  The repeat count must be a positive integer.  You can not use this
  feature just after conditional rules, because repeated rules are not
  counted as a single rule for syntactic purposes:



               if  $something
                       2x   regress   0>x(!_!)   #...wrong!




  You should rewrite this to



               if  $something
               {
                       2x   regress   0>x(!_!)
               }

  Huge integers (like one million) are disallowed.  This is because the
  current implementation needs a few bytes of memory (one pointer) per
  every repetition.




  22..1100..  CCoonnddiittiioonnaall rruulleess


  The conditional rules execute the following rule if and only if a
  condition is met.  The condition is specified as the parameter, the
  following (conditioned) rule is given on a separate line (or lines, if
  a ``composite rule'' follows).  (Comments, whitespace and empty lines
  may intervene as usual.) It is not syntactically necessary to indent
  the conditioned rules with whitespace, but it is strongly recommended
  for readability.


  22..1100..11..  TTyyppee iinnssiiddee


  Apply a rule or a block of rules within certain units only.  The
  parameter is a list of values at the scope level, wherein the
  following rule should be applied; the "except" operator may be used.

  Every unit (a sentence, for example), which fulfills the criterion, is
  processed separately, therefore the scope of the following rule may be
  at most that of the inside rule itself.


  22..1100..22..  TTyyppee wwiitthh


  Apply a rule or a block of rules for a list of units.  In contrast
  with the preceding rule type, this refers not only to the token at the
  scope level (such as space), but to the whole structure (such as the
  string of phones delimited by the space).

  The parameter is a filename; the file should list the strings subject
  to the following rule, such as special words.


  22..1100..33..  TTyyppee iiff


  Apply a rule or a block of rules only if a condition (given by the
  parameter) is met.  The condition must currently be specified as a
  boolean voice configuration option (possibly a soft option) or its
  negation (i.e. prefixed with an exclamation mark).

  Example:


       if   !colloquial
       {
               ...
       }




  The rules within the block will be applied only if the colloquial
  option is _n_o_t set.


  This if rule inherits its scope from its parent rule if not specified
  explicitly.

  Again, the scope of a subordinate rule may not be larger than that of
  the if rule itself.



  22..1111..  SSppeecciiaall rruulleess

  22..1111..11..  TTyyppee rreeggeexx


  Regular expression substitution.  The parameter is of the form
  /regular_expression/replacement/.  This rule type is similar to subst,
  but it is more powerful and more arcane; it is not intended for end
  wizards.  Skip it.

  For a regular expressions' overview  try man grep.  Note a difference:
  in "regular" regular expressions, parentheses match themselves, while
  the open group and close group operators are \( and \), respectively.
  As we use groups heavily and next to none real parentheses, we decided
  to do it the other way round.

  The replacement may contain escape sequences referring to the match of
  the n-th group within the regular expression: \1 to \9.  \0 represents
  the entire match, but this is probably unusable under the current
  design, as this would cause an infinite substitution loop.

  In order to use this type of rule, you need to have the rx or regex
  library already installed and have WANT_REGEX enabled in common.h.
  This is because we don't actually implement the regex parsing stuff;
  we leave it to your OS libraries.  In case you don't have such
  libraries installed, we use the glibc implementation (rx.c in the
  distribution).


  22..1111..22..  TTyyppee ddeebbuugg


  Debugging information during the application of the rules.  Scope and
  target are ignored, the parameter is parsed lazily.

  Parameter "elem": dump the current state of the text being processed
  Parameter "pause": wait until keypress




  22..1122..  TThhee ""eexxcceepptt"" ((!!)) ooppeerraattoorr


  Whenever an unordered list of tokens should be specified within the
  parameter to some rule (use common sense and/or individual rule
  descriptions above), you can also make negative specifications, such
  as "all consonants except l and r".  To do this, use the exclamation
  mark serving as an "except" operator: $consonants!lr (The right
  operand is subtracted from the left one.)  If there is no left
  operand, say in !x, the semantics is "all but x".  You see that !
  alone means "everything".

  The operator is right-associative; !$vowels!ou means "all excluding
  vowels, but o and u don't count as vowels just now".

  Let us repeat that this operator will never work for ordered lists,
  not even for the syll rule sonority groups.
  22..1133..  EEssccaappiinngg ssppeecciiaall cchhaarraacctteerrss


  You can use the backslash to escape any special character including
  itself anywhere in the rules or .ini file strings.  \n, \t, \[ may be
  used to insert a newline, tab, or escape characters, respectively.



  33..  OOppttiioonnss


  Most aspects of the operation can be customized by changing options.
  This can be enforced by TTSCP commands, in configuration files and on
  the command line. Basically, an option is an option name/option value
  pair. There are a few possible option types: number, string, yes/no,
  character, and a few enumerated types.

  Almost all individual options are documented in ``this document''.
  The reliable list of all built-in long options can be found in
  src/options.cc.  (See approximately line 275 and below. Every line
  represents at most one option for every option class as explained
  below. The option name is quoted; its semantics is usually explained
  following the option.)  You can also list their names and types using
  epos -H.


  33..11..  OOppttiioonn ccllaasssseess


  Basically, there are three major classes of options: global options,
  language options and voice options. For instance, switching a voice
  means switching to another set of voice options, while the language
  options and global options stay the same.

  Every voice is language specific (implies a specific language).
  That's why switching the language automatically switches the voice to
  the voice defined as default for this particular language.  (It is
  however possible to use the same configuration file to setup a
  similarly sounding voice for every language if desired.)

  A set of voice options should completely describe a voice.  A set of
  language options should completely describe a language, except for
  voice-specific behavior. A set of global options should cover language
  independent aspects of operation.  It should be understood that a set
  of options may employ various references to other information,
  especially filenames (of language dependent transcription rules, voice
  dependent diphone inventories etc.)

  Some language and/or voice specific options may have suitable defaults
  for all but specific languages/voices. Every voice option thus has its
  corresponding language option to default to if unspecified for a given
  voice. Likewise, there is a global option for every language option to
  default to. Therefore, adding a new language or voice options doesn't
  necessarily imply adding them to each language or voice configuration
  file, if a reasonable default can be suggested.

  Whenever an option name is given, it is first understood as a voice
  option (of the current voice); if there is no such voice option, the
  name is treated as a language option, then as a global option. To
  override this order, you can prefix an option with "C:", "L:" or "V:".
  This will restrict the search to global, language or voice options,
  respectively.  (This is automatically done with configuration files,
  because every configuration file describes either a language or a
  voice, or it is unrelated to the current language and voice
  altogether.)
  33..22..  CCoonnffiigguurraattiioonn ffiilleess


  Whenever the program starts up, it reads a number of configuration
  files, setting up the initial (default) values of the options.  These
  are typically located under /usr/lib/epos (can be overridden with the
  --base_dir option on the command line). By convention, configuration
  file names have the ".ini" suffix.

  Unless overridden, three files in /usr/lib/epos/cfg will be processed
  to setup the global configuration: fixed.ini, epos.ini and either
  ansi.ini or rtf.ini (depending on the preferred output format if
  colored output is turned on -- either ANSI escape sequences or RTF are
  supported at the moment; other markup formats can be added easily).
  By convention, fixed.ini contains the standard global configuration
  values used by a given installation and rarely or never changes, while
  epos.ini contains less permanent parameters and temporary values.  The
  global parameters include a list of _l_a_n_g_u_a_g_e_s, or language
  configurations which will be parsed when the global configuration is
  set up.  Every language .ini file in turn contains a list of voices to
  be configured for this particular language. Language configuration
  files are located under /usr/lib/epos/lng/*/*.ini, voice configuration
  files under /usr/lib/epos/inv/*/*.ini, where * represents any string
  listed in the list of languages (or voices for a language). Go see the
  real files under /usr/lib/epos/cfg/*.ini for an example.

  If a EPOSCFGFILE environment variable is set upon the main program
  startup, its value is a file name to be parsed instead of epos.ini.


  33..22..11..  CCoonnffiigguurraattiioonn ffiillee ffoorrmmaatt oovveerrvviieeww


  A configuration file contains one option per line (empty lines are
  ignored).  Each option is a name-value pair, separated with
  whitespace.  A string value may be (and sometimes must be, e.g. if it
  begins with whitespace) enclosed in double quotes.  Every
  configuration file is associated with a certain option set, that is,
  it contains either just global options, or options related to some
  language or voice. (In the latter two cases, the name option
  identifies the language or voice properly.)


  33..22..22..  EEssccaappiinngg ssppeecciiaall cchhaarraacctteerrss


  It is possible to enter some special characters using escape
  sequences, such as "\ " for a space, "\n" for a newline, or "\~" for
  "..." or "dots" (treated as a single character in Epos).  The
  available escape sequences are listed in ``the table of escape
  sequences''.


  (If you suspect this table to be out-of-date, you can consult the
  token_esc and value_esc constants in option.cc, or the table in
  parser.h.) ASCII codes in parentheses are ASCII codes used for
  different purposes by Epos.



  33..22..33..  CCoommmmeennttss aanndd tthhee ##iinncclluuddee ddiirreeccttiivvee


  A configuration file usually contains various comments. A comment can
  start on any line with a semicolon or hash mark and lasts to the end
  of line.  The semicolon (or hash mark) must be located at the
  |                 |                  |                       |             |
  |__________________|___________________|________________________|_________     |
  |escape sequence  |  interpreted as  |  ASCII code, decimal  |  example    |
  |__________________|___________________|________________________|_________     |
  |\n               |  newline         |  10                   |             |
  |\t               |  tab             |  9                    |             |
  |\e               |  escape          |  27                   |             |
  |\E               |  escape          |  27                   |             |
  |\[               |  escape          |  27                   |             |
  |\\               |  backslash       |  92                   |             |
  |\                |  hard space      |  255                  |             |
  |\#               |  hash            |  35                   |             |
  |\;               |  semicolon       |  59                   |             |
  |\~               |  dots            |  (1)                  |  No...      |
  |\.               |  decimal point   |  (2)                  |  1.2 kg     |
  |\-               |  range           |  (3)                  |  2-3 people |
  |\m               |  minus           |  (4)                  |  -1         |
  |\X               |  temporary       |  (31)                 |             |
  |__________________|___________________|________________________|_________     |


               Escape sequences used in configuration files
  beginning of line or just after some whitespace. Semicolons in the
  middle of a word don't start a comment.

  As an exception, if a line begins with #include starting in the first
  column, it is treated as the _i_n_c_l_u_d_e _d_i_r_e_c_t_i_v_e.  The format of the
  line should be #include "filename" and it will cause the contents of
  the filename file to be inserted at this place of the main .ini file.
  These includes can be nested to any finite depth; if no or relative
  path is specified, the directory which holds the topmost file is used
  for the lookup.

  Two more directives, #warn and #error with obvious semantics are
  available for diagnostic purposes.


  33..33..  CCoommmmaanndd lliinnee


  There are three kinds of command line: the _d_a_e_m_o_n one, the _c_l_i_e_n_t one,
  and the _m_o_n_o_l_i_t_h_i_c Epos binary. The following description is a little
  bit chaotic in this respect; please do experiment if unsure.

  FIXME: see preceding paragraph

  In both the daemon and monolithic shape it is possible to override
  configuration file supplied values at the command line. All options
  may be overridden using _l_o_n_g _o_p_t_i_o_n_s, i.e. the option name preceded by
  two dashes and followed by a value (unless the option is a truth value
  (boolean) and the value desired is true or, for a string option, the
  empty string).  The ordering of the options on the command line is not
  significant.  An example:



       say --language german --pausing "Wie geht es?" --show_diphones




  This sets the default language to German, enables pausing after each
  transformation rule is applied to the text (sets the pausing option to
  true, in other words) and prints the diphone string generated in the
  process (sets the show_diphones option to true). The string to be
  transcribed and synthesized is given on the command line as well (it
  must be quoted unless it consists of a single word).

  The list of all available long options together with their types can
  be obtained with epos -H of the main program (not the client stub,
  sorry).  The semantics of nearly all individual long options is
  described ``below''.

  The most frequently used options and occasionally even common sets of
  options are given a shortcut, called a _s_h_o_r_t _o_p_t_i_o_n.  A short option
  is a single letter preceded by a single dash.  Usual conventions for
  merging short options are available, therefore the example above may
  be abbreviated as



       say --language german -p "Wie geht es?" -d




  or even



       say --language german -pd "Wie geht es?"




  (There  is no short option for --language.)  For turning long boolean
  options off, it is possible to give their name with three dashes.
  Therefore,



       say ---show_transcript "Say this, do not show the transcription"




  is equivalent to



       say --show_transcript off "Say this, do not show the transcription"




  A list of (the most of) the short options can be obtained with epos
  --help, or epos -h.

  The options on the command line are processed left to right.  They
  take precedence over the configuration files (unless common sense
  rules otherwise).



  33..44..  SSeettttiinngg ooppttiioonnss iinn TTTTSSCCPP


  See the ``TTSCP specification'' for general overview of TTSCP and the
  set command.



  33..44..11..  aalllloowweedd..iinnii ffiillee


  Setting options in TTSCP can be a security problem, as some options
  can cause the server to access unrelated files. It is therefore
  strongly recommended not to run the Epos daemon with superuser
  privileges, but sometimes more fine-grained access control mechanism
  is needed.  It is authentication and limiting access to specified
  options for some or all users.

  By default, all settable parameters can be changed by any outside
  connection (this doesn't affect any other connections in any way).
  You can control this privilege by restricting it in cfg/allowed.ini.

  Every line of that file is in the form



       option_name       access_rights




  The _a_c_c_e_s_s _r_i_g_h_t_s must be in lowercase and must not contain spaces.
  They are a sequence of r, w', $ and #, none of which may be repeated.
  Their order is significant, the interpretation is as follows:


  +o  if no r is mentioned, nobody can read the option value

  +o  if no w is mentioned, nobody can change the option value

  +o  if a r or w appears without $ or # to the left of them, they grant
     the read and write rights, respectively, to even anonymous
     connections.

  +o  following $, they grant the respective rights to any authenticated
     user.

  +o  following #, they grant the respective rights to the root only.

       |           |                                               |
       |____________|________________________________________________|_____
       |r          |  read only                                    |
       |w          |  write only                                   |
       |rw         |  no restriction                               |
       |#w$r       |  root can write, authenticated users can read |
       |r#w        |  anyone can read, root can also write         |
       |#rw        |  root can read/write                          |
       |____________|________________________________________________|_____


                     Examples of option access rights

  Unknown parameters are considered just not to have been implemented in
  this particular version of Epos and are not reported. Parameters not
  mentioned in allowed.ini are allowed unlimited access by any
  connection.


  33..55..  SSeemmiippeerrmmaanneenntt ppeerrssoonnaall pprreeffeerreenncceess


  If many users with different needs and aesthetic feelings share the
  same Epos daemon installation, they may choose to place the
  appropriate TTSCP commands into a file and to point the TTSCP_USER
  environment variable to this file.  The contents of that file will be
  transmitted by the client to set up the working environment at the
  beginning of every session.

  An example:



       set language czech
       set voice kadlec
       set init_f 90
       set init_i 110
       set language slovak




  This example will adjust the preferred pitch and volume for a certain
  Czech voice; it will also set the default language to Slovak. See the
  ``TTSCP specification'' for more info.


  33..66..  SSoofftt ooppttiioonnss


  Most options (discussed until this point) have built-in meanings and
  semantics; for most uses this is sufficient and necessary.  However,
  the user may also decide to define additional options to be provided
  by a language to its voices. This mechanism is called _s_o_f_t _o_p_t_i_o_n_s;
  soft options are always voice options and are described at the
  language level (that is, the name, type and default value is supplied
  with the language, but individual voices may choose to specify a value
  for the option).

  The soft options are described by the language option soft_options.
  It is a list of colon separated descriptions of individual soft
  options; every item is of the format name[(type)][=default], where
  name is an arbitrary option name, type is either b or s (meaning
  boolean or string; other possibilities include n, c for integers and
  characters, but these are untested and don't seem to be widely useful.
  The default is the default value to be used if the option is left
  unspecified by a voice. It should be chosen as a backward compatible
  value for a new option if applicable.

  The type and/or the default may be left unspecified. The default type
  is boolean, the default default is an empty string.

  An example:



               soft_options   "colloquial=false:diphone_listing_file(s)=traditnl.dph"




  This example defines two options, a boolean colloquial and a string
  diphone_listing_file.

  The sets of soft options for individual languages are independent and
  never clash with each other. However, built-in option names may not be
  used as soft option names.




  33..77..  SSeelleecctteedd ooppttiioonnss


  To begin with, this subsection is very completely incomplete and can
  be expected to grow at a moderate pace just now.

  A few individual options will be described in this section.  The rest
  are either straightforward or rarely useful. A complete list of
  options can be obtained through epos -H or in src/options.cc.

  The type and the semantic class of the argument is indicated for all
  individual options except for truth value (on/off) options.  This is
  because these options, when found without an argument, are
  automatically interpreted as on.

  Many options may not make any sense to you; indeed, some of them don't
  actually make sense to me.  Such options are usually relics from now
  forgotten ad hoc configurations.  I appreciate any suggestions on how
  to replace any old fashioned configuration mechanisms with more
  generic and/or simpler ones.


  33..77..11..  OOvveerraallll ooppttiioonnss


  Some options control overall preferences, strategies and assumptions
  to be used by Epos.  Most of them are global booleans.  They are
  usually of technical nature and the output produced by Epos should not
  change with these options changed, but they can be useful in some
  special configurations.  They also get added to resolve some simple
  software engineering dilemmata.


     ----ccoommmmaa _d_e_l_i_m_i_t_e_r
        This is the delimiter for Epos-generated lists, especially in
        TTSCP; an arbitrary string is allowed.  Do not change.

     ----ddeeffaauulltt__cchhaarr _c_h_a_r_a_c_t_e_r
        The character to replace any unknown characters in the input
        text.  See also the relax_input option.

     ----eenndd__ooff__ffiillee _c_h_a_r_a_c_t_e_r
        The character to terminate the input text.  This defaults to the
        escape character.  The length of the input text is usually
        defined externally (by the apply command within a control TTSCP
        connection or by the end of an input), however, there are cases
        where this is not applicable or desirable for some reason.  The
        character specified by this option terminates the input text,
        but not the input stream.  It is also necessary to press Enter
        after the character. Applies only to the monolithic Epos.

     ----ffoorrkkiinngg
        Turn on to allow forking and fully detaching the Epos daemon.
        Usable only on unices.  If off, some debugging information will
        be written to stdout in some configurations.

     ----mmaarrkkuupp__llaanngguuaaggee _m_l
        The parameter is either "ansi", "rtf" or "none". This parameter
        is only effective in fixed.ini or on the command line.
        Depending on its value, the ansi.ini or rtf.ini configuration
        file is appended to the fixed.ini file during parsing the
        configuration.  These two files contain the complete output
        formatting information necessary for printing text in either the
        ANSI escape sequences (ISO 6429) or the Rich Text Format; they
        use colors to distinguish between symbols of different levels of
        description.
     ----mmeemmoorryy__llooww
        Turn on if you're very low on memory. This mode sacrifices speed
        for a little bit of saved memory. Basically, turning this on
        caused various dictionaries to be discarded whenever the rule
        which has used them has been applied and reloaded the next time
        it is needed.  Likewise, cached files are released upon the last
        unclaim.  Otherwise these data structures are kept cached in for
        the next use.

     ----ppaarraannooiidd
        With this option on, Epos will tend to detect more errors in
        various kinds of input files than without.  It will rather try
        to reject suspicious or formally incorrect inputs, than to do
        something reasonable with them. Useful for debugging.

     ----ppaauussiinngg
        With this option on, Epos will pause and wait for a keypress
        after every rule is applied.  Of course, this is incompatible
        with the forking option and some other setups.  Should be only
        used for debugging.

     ----ppttrr__ttrruusstteedd
        One of the checks performed when the ``trusted'' option is
        disabled is checking whether some pointers are actually
        pointers, that is, very big numbers when cast to an integer.
        This can be useful on some machines, but it is absolutely
        unportable.  It may or may not work with your compiler; enable
        this option to skip these checks.

     ----rreellaaxx__iinnppuutt
        Turn on in real life situations.  When off, Epos will quit
        parsing any text which contains an unknown character (not listed
        in on of the perm_* options).  This option replaces such
        characters with the value of the default_char option before
        they're classified.

     ----sshhooww__rruullee
        Print each rule before it is applied.  This is useful mostly for
        debugging situations (when a text is parsed in an unexpected way
        and the user is trying to find out which rule has escaped his
        attention). This option may not work with all setups.

     ----sshhrriieekk__aarrtt nnuummbbeerr
        The picture to be printed to stdshriek in case of an error.  May
        or may not work.  Small integers such as 0, 1 or 2 are possible.

     ----ttrruusstteedd
        Code related to the class unit often calls its sanity method to
        detect any serious structure violation before it makes Epos
        crash mysteriously.  In stable versions, however, these checks
        are unlikely to be necessary.  Use this option to skip them.

     ----vveerrbboossee
        When the rules are dumped with the debug rule type and this
        option is set, all of them will be displayed.  Otherwise only
        the current rule is displayed.  That's all.


     ----llaanngguuaaggeess _l_i_s_t
        Lists initially available languages. The parameter is a colon
        separated list of language names. Every language must have its
        associated .ini file; the name of the file is obtained by
        suffixing .ini to the language name, while the directory name
        matches the language name and is located under the directory as
        determined by the lang_base_dir option.  The first language
        listed will become the default language.
  33..77..22..  TTyyppeess ooff oouuttppuutt

  FIXME: the following options often reasonably work only for the
  monolithic version of Epos.  Should be checked out, unified and
  documented.


     ----sshhooww__ttrraannssccrriipptt
        Print the transcription of the text processed.

     ----sshhooww__pphhoonneess
        Print the sequence of sounds generated from the text processed.

     ----sshhooww__ddiipphhoonneess
        Print the sequence of diphones generated from the text
        processed.

     ----sshhooww__rraaww__ddiipphhss
        When used in conjunction with the show_diphones option, the
        diphones will be not only listed by name, but they will also
        include the actual numbers generated.

     ----ppllaayy__ddiipphhoonneess
        Synthesize the waveform and say it through the sound card or
        write it to a file, as pointed to by the wave_file option
        option.

     ----wwaavvee__hheeaaddeerr
        When dumping the waveform into a file, put the traditional wav
        file header at its beginning.  Regardless of this value, the
        header is never added when writing the waveform to a device (a
        file descriptor which understands the usual ioctls).

     ----iimmmmeedd__ddiipphhoonneess
        Print the sequence of diphones generated from the text processed
        just after the diphones rule.  This is useful especially in
        conjunction with the neuronet option where the diphone layer is
        created, but later to be discarded by the rules.

     ----nneeuurroonneett
        Very experimental. See doc/czech/nnet.doc for more info.

     ----hheellpp
        Print a brief synopsis of short options upon startup.  No data
        processing is performed.

     ----lloonngg__hheellpp
        Print a list of long options upon startup.  No data processing
        is performed.

     ----vveerrssiioonn
        Print the current version number to stdshriek upon startup.



  33..77..33..  TTeexxtt oouuttppuutt ffoorrmmaattttiinngg


  You can tailor the conventions for printing out processed text quite a
  lot.  Basically, we're printing out a ``text structure
  representation'', so that we can see what level of description does a
  character belong to.  Preserving this information in the output is
  often very desirable; it can either be done by inserting delimiters
  such as custom syllable breaks, or by coloring some levels of
  description.

  This family of options can result in a quite complex configuration.
  That's why we provide at least two complete sets of settings in
  ansi.ini and rtf.ini. You can use the ``markup_language'' option to
  switch between them in  fixed.ini.

  Some options control the colors used for output.  For the time being,
  these options actually take the escape sequence needed to switch the
  color for the current format (e.g. ANSI escape sequences or RTF).  In
  principle, other strings than escape sequences can be printed, but
  such configuration is discouraged.

  Some options configure the appearance of the ``TSR'' to the user.  The
  model we use is assigning a few colors consistently to the individual
  levels of description and marking up the boundaries between units with
  parentheses, separators or both. The levels of description are
  ``defined'' in compile time.  The diphone and text may not be
  applicable for some of these options. This model of displaying the TSR
  is not used for transmitting the text over TTSCP.


     ----ccoolloorreedd
        If disabled, all color manipulating options will be ignored.
        Many configurations will enable this by default, because the
        escape sequences are rarely usable directly and never
        indirectly.

     ----nnoorrmmaall__ccoolloorr _c_o_l_o_r
        String to switching to the neutral (default) color. Issued at
        the end of every colored piece of text.

     ----ccuurrrr__rruullee__ccoolloorr _c_o_l_o_r
        String to switch to the a _b_o_l_d color.  The bold color will be
        used to highlight the current rule in the list of rules printed
        by the ``debug rule type''.

     ----ffaattaall__ccoolloorr _c_o_l_o_r
        String to switch to the color used for printing out fatal error
        messages.


     ----hheeaaddeerr _f_i_l_e_n_a_m_e
        The value is the file name of a file in the directory specified
        by the ini_dir option, which is to be printed before any
        phonetic transcription.

     ----ffooootteerr _f_i_l_e_n_a_m_e
        The value is the file name of a file in the directory specified
        by the ini_dir option, which is to be printed after any phonetic
        transcription.

     ----bbeeggiinn__** _s_t_r_i_n_g
        The asterisk stands for a symbolic name of a linguistic
        description level, such as phone, syll or word.  The parameter
        is a string which will be printed before the first unit within
        this unit, for example before the word-initial syllable in case
        of begin_word).

     ----cclloossee__** _s_t_r_i_n_g
        The asterisk stands for a symbolic name of a linguistic
        description level, such as phone, syll or word.  The parameter
        is a string which will be printed after the last unit within
        this unit, for example before the word-final syllable in case of
        close_word).

     ----ccoolloorr__** _s_t_r_i_n_g
        The asterisk stands for a symbolic name of a linguistic
        description level, such as phone, syll or word.  The parameter
        is the string to switch the color for this level of description.

     ----sseeppaarr__** _s_t_r_i_n_g
        The asterisk stands for a symbolic name of a linguistic
        description level, such as phone, syll or word.  The parameter
        is a string which will be printed between adjacent units of this
        level of description, for example between words in case of
        begin_word).

     ----ssttrruuccttuurreedd
        Whether the verbose model of displaying the TSR as described
        above is used. When off, only the text itself is printed and
        simple spacing is used to delimit units which do not correspond
        to actual characters.  This option is orthogonal to the colored
        option.

     ----ppoossttffiixx
        If on, the upper level characters (such as punctuation) are
        printed after the lower level characters (such as letters or
        sounds) in the phonetic transcription.

     ----pprreeffiixx
        If on, the upper level characters (such as punctuation) are
        printed before the lower level characters (such as letters or
        sounds) in the phonetic transcription.  Disabling both prefix
        and postfix options effectively disables printing other
        characters than sounds.  This option is orthogonal to the
        structured option.

     ----sswwaallllooww__uunnddeerrbbaarrss
        Epos uses the low line (_) character to represent suprasegmental
        units with no content at their level (e.g. syllables are often
        only implicitly terminated or even generated by the rules and
        have no associated symbol.); this option, when enabled,
        suppresses them completely.



  33..77..44..  LLiimmiittss


  Most algorithms used in Epos are boundless, avoiding techniques like
  fixed size arrays or buffers.  On the other hand, there are instances
  when this is inadequate, especially for speed or space considerations.
  In these cases Epos tries to use growable data structures, so that
  they perform well up to a certain size limit and then somewhat slower,
  but still correctly.  We call such a limit a _s_o_f_t _l_i_m_i_t, as opposed to
  a _h_a_r_d _l_i_m_i_t which cannot be exceeded.  Most limits in Epos are
  configurable and soft, but some hard limits have also been imposed.
  This subsection also covers some time vs. space trade-off
  configuration parameters, though these are no limits at all. Also some
  _s_a_n_i_t_y _c_h_e_c_k _l_i_m_i_t_s are imposed; these act as hard limits, but can be
  effectively disabled by setting them to absurdly high values (and even
  then they may correctly enforce a certain type of a sanity check).

  In fact, you can ignore this section completely, as the few hard
  limits tend to employ absurdly high values.


     ----ddiipphh__bbuuffff__ssiizzee _d_i_p_h_o_n_e_s
        Soft limit.  Maximum number of diphones generated by the
        diphoniser and synthesized at once. It more diphones have to be
        generated, they are synthesized in chunks of diph_buff_size.
        This option has no effect in the monolithic Epos.

     ----bbuuffffeerr__ssiizzee _b_y_t_e_s
        Soft limit. The initial buffer size for a wave file. This value
        is not used, if we already know that we will eventually write
        this waveform to a sound card device; in this case we use ioctls
        to find out the size of its hardware buffer to maximize the
        chance of getting a smooth playback.

     ----ddeevv__tteexxtt__lleenn _b_y_t_e_s
        Sanity check limit.  When reading from a device, this is the
        maximum amount of data which will be read for processing.  This
        is not necessary when reading from a file, because the length of
        a file can be known in advance and it is always finite.

     ----hhaasshheess__ffuullll _p_e_r_c_e_n_t_a_g_e
        Trade-off. Controls how full should a hash table ideally be.
        The hash tables used in Epos are actually quite robust
        performance-wise, so that even values like 1000, that is, ten
        data items per a hash table slot, result in reasonable speed.
        Values somewhere below 100 are the best bet.

     ----mmaaxx__lliinnee__lleenn _c_h_a_r_a_c_t_e_r_s
        Hard limit. Maximum line length in a text-oriented input file.
        Longer lines are truncated.

     ----mmaaxx__nneett__ccmmdd _c_h_a_r_a_c_t_e_r_s
        Hard limit. Maximum TTSCP command length. TTSCP lines longer
        than this will be truncated.  The protocol requires this value
        to be at least 80, but a few kilobytes is recommended.

     ----mmaaxx__rruullee__wweeiigghhtt _w_e_i_g_h_t
        Sanity check limit. Maximum rule weight in a choice, as well as
        the maximum rule repeat count. Using very large weights can
        result in memory exhaustion.  Values on the order of 10000 are
        still perfectly safe.

     ----mmuullttii__ssuubbsstt _c_o_u_n_t
        Sanity check limit.  How may substitutions will be applied to a
        unit during processing of a subst rule.  The rule is applied
        until the unit settles down or until this limit is reached.  In
        the latter case, the substitution is considered impossible
        (infinite).

     ----rruulleess__iinn__bblloocckk _c_o_u_n_t
        Soft limit. Number of rules used in a block of of rules.

     ----ssccrraattcchh__ssiizzee _b_y_t_e_s
        Hard limit.  Epos uses a temporary internal buffer in a few
        places.  Usually only very few bytes of the buffer are needed,
        but overflowing it is fatal. It is recommended to provide at
        least a few hundred bytes, preferably kilobytes, for this
        buffer.

     ----vvaarriiaabblleess _c_o_u_n_t
        Soft limit. Number of variables used in a set of rules.



  33..77..55..  LLaanngguuaaggee ddeeppeennddeenntt ccoonnffiigguurraattiioonn


  This subsection lists some options defined for each language.
  Additional language dependent options are certain directory and file
  names and possibly others.  As every voice is associated with a single
  language (two voices may share a multilingual diphone inventory if
  desired), every voice dependent option is thence language dependent.

     ----vvooiicceess _l_i_s_t
        Lists initially available voices. The parameter is a colon
        separated list of voice names. Every voice must have its
        associated .ini file; the name of the file is obtained by
        suffixing .ini to the voice name while the directory name
        matches the voice name and is located under the directory as
        determined by the per language (default) inv_dir option.  The
        first voice listed will become the default voice for its
        language.

     ----ssoofftt__ooppttiioonnss _l_i_s_t
        Lists available soft options as described in subsection ``soft
        options''.

     ----ssuupppprreessss__ssiiddee__ssyyllll
        This option should be off for most languages.  It makes the syll
        rule avoid splitting off an insufficiently sonorous word-initial
        pseudo-syllable. It is an ugly hack originally introduced to get
        the Czech syllabification right, but I am still not aware of
        related phenomena or possible generalizations.

     ----lliimmiitt__ssiiddee__ssyyllll _s_o_u_n_d
        This parameter is only considered if suppress_side_syll is
        enabled.  The parameter is the least permissible sonorous sound
        to serve as a sonority peak if it happens to be word-initial.
        (More precisely: permissible target unit, scope-initial, as
        defined by the individual syll rule.)

     ----rruulleess__ffiillee _f_i_l_e_n_a_m_e
        The parameter is a filename. The file contains the
        transformational rules to be applied for this language.

     ----ppeerrmm__** _s_e_t
        The asterisk stands for a symbolic name of a linguistic
        description level, such as phone, syll or word.  The parameter
        is a simple sequence of all characters belonging to this level
        of description. For example, perm_phones will list letters,
        numbers and other segmental symbols.  Punctuation will be
        assigned to the higher level sets.  The sets should be disjoint
        and only the characters actually processed by the rules should
        be listed here.  The language independent built-in parser tries
        to resolve the most common ambiguities of Latin-based writing
        systems, like periods.


  33..77..66..  VVooiiccee ddeeppeennddeenntt ccoonnffiigguurraattiioonn



     ----nnaammee _v_o_i_c_e_n_a_m_e
        This option assigns a name to a newly created voice.  If there
        is no name specified, this option defaults to the configuration
        file name (from the last slash to the nearest dot) the
        configuration has been loaded from.  The name is then used to
        refer to the voice in TTSCP.

     ----ttyyppee _s_y_n_t_h_t_y_p_e
        The parameter, the speech synthesis type, is one of the
        following:

        This option may influence other voice dependent options quite
        significantly, as some of them are speech synthesis type
        dependent.

     ----rreemmoottee__sseerrvveerr _h_o_s_t_n_a_m_e_[_:_p_o_r_t_]
        If this speech synthesis is of the internet type, this option
  |           |                                                                   |
  |none       |  voice is mute                                                    |
  |internet   |  voice uses a remote speech synthesis using TCP/IP                |
  |lpc-int    |  voice uses a LPC synthesis (integer diphone inventory)           |
  |lpc-float  |  voice uses a LPC synthesis (float diphone inventory)             |
  |lpc-vq     |  voice uses a LPC synthesis (vector quantified diphone inventory) |
  |ktd        |  voice uses a time domain synthesis                               |

        can be used to set the hostname of the remote server.  If the
        server is listening on a non-standard port number (currently the
        standard port is considered to be 8778), the host name may be
        followed by a colon and the port number requested. This option
        doesn't affect other synthesis types.

     ----mmooddeellss _f_i_l_e_n_a_m_e
        The value is a file name. The file contains the diphone
        inventory proper. Its format is speech synthesis type dependent.

     ----ccoouunnttss _f_i_l_e_n_a_m_e
        The value is a file name. The file contains the lengths of
        individual diphones in this diphone inventory.

     ----ddpphh__ffiillee _f_i_l_e_n_a_m_e
        The value is a file name. The file contains the diphone
        descriptions in the format used by the diph rule. FIXME: odkaz
        nebo popis

     ----ddpptt__ffiillee _f_i_l_e_n_a_m_e
        The value is a file name. The file contains the symbolic diphone
        names for user output.

     ----ccooddeebbooookk _f_i_l_e_n_a_m_e
        The value is a file name. The file contains the code book for
        the vector quantified LPC speech synthesis (lpc-vq type only).

     ----iinnvveenntt__ddiirr _d_i_r_n_a_m_e
        The voice dependent value is a directory name.  The directory
        shall contain the diphone inventory file (or files) used by the
        voice.  The global (default) value at the same time serves as
        the base name for looking up newly constructed voices.

     ----iinniitt__ff _p_e_r_c_e_n_t_a_g_e
        The auditory neutral integer value for the fundamental
        frequency.  The typical value is 100.

     ----iinniitt__ii _p_e_r_c_e_n_t_a_g_e
        The auditory neutral integer value for the volume.  The typical
        value is 100.

     ----iinniitt__tt _p_e_r_c_e_n_t_a_g_e
        The auditory neutral integer value for the prosodic duration of
        diphones.  The typical value is 100.  Of course, it is diphone
        length relative (some diphones are longer than others), just as
        the init_f and init_i options are.

     ----cchhaannnneell _c_h_a_n_n_e_l_t_y_p_e
        The parameter, the output channel type, is one of the following:
       |           |                                               |
       |mono       |  mono output signal                           |
       |first      |  stereo output signal, second channel is mute |
       |second     |  stereo output signal, first channel is mute  |
       |both       |  stereo output signal, two identical channels |


        This option may be used to simulate a dialogue by assigning
        different output channels to different speakers.
     ----iinnvv__ssaammpplliinngg__rraattee _H_z
        The sampling rate this diphone inventory has been recorded at.
        The algorithms we use also imply that we use the same frequency
        for the synthesis.

     ----ssaammppllee__ssiizzee _b_i_t_s
        Number of bits per sample.  If some kind of a stereo output is
        turned on, this option set the number of bits per channel.
        Again, this is related to the quality of recording of the
        diphone inventory.  We currently only support 8 and 16 bits.



  33..77..77..  PPrroossooddyy ggeenneerraattiioonn


  The options in this section control how the resulting per diphone
  prosodic information is assembled from the prosodic adjustments done
  to the structural units by the rules.  It actually controls the
  interpretation of those adjustments themselves.


     ----pprrooss__wweeiigghhtt__** _w_e_i_g_h_t
        The asterisk stands for a symbolic name of a linguistic
        description level, such as phone, syll or word.  The parameter
        is an integer value primarily used for enabling (1) or disabling
        (0) certain levels of description when the total quantities for
        a diphone are computed.  It must however be understood that when
        some rules like smooth are applied, the prosodic values are
        distributed down to the target level of such a rule and cannot
        be distinguished anymore.  If higher values than 1 are set, that
        will multiply the prosodic effect assigned to a level
        correspondingly.

     ----pprrooss__eeffff__mmuullttiippllyy__**
        The asterisk stands for a single letter, f, i or t, that is, a
        prosodic quantity symbol.  This option controls how are the
        prosodic values for individual levels of description combined.
        If it is off, they are summed up (taking the corresponding
        pros_neutral_* as the baseline); if it is on, they get
        multiplied with each other (again taking pros_neutral_* as the
        neutral value). See ``prosody modelling'' for more information
        and examples.

     ----pprrooss__nneeuuttrraall__**
        The asterisk stands for a single letter, f, i or t, that is, a
        prosodic quantity symbol.  This option controls what prosodic
        value is to be considered neutral for use in Epos. The current
        configuration file use 100 and prosodic adjustments are
        essentially percentages, but a higher value could be used for
        more fine grained prosody control (provided the synthesis
        algorithms can take advantage of it).














  33..77..88..  FFiillee nnaammiinngg

  In Epos, most of the files ever opened are located in a single
  directory tree (usually /usr/lib/epos); the files of the same type --
  and related to the same language or voice, if applicable -- are
  located in the same subdirectory by default.  Thus, the path name
  actually used by Epos consists of the base directory path, the
  subdirectory (or directory for short) and a relative file name.  This
  makes it possible to move either the whole configuration structure, or
  a specific part of it, or a single file to another place.

  The relative file name may contain slashes (directory name
  separators).  If they only occur in the middle of the name, the file
  name is still relative to the directory it would normally be located
  in.  However, if the file name begins with a slash or with ./, the
  file is treated as absolute or relative to the current working
  directory of the Epos process, respectively.  The second case is thus
  slightly undefined, but the first one allows to place any file in an
  arbitrary directory.  Likewise, if the directory name begins with a
  slash, it is not considered to be relative to the base directory.

  Changing these options in run time does not immediately cause re-
  reading the renamed files.


     ----bbaassee__ddiirr _d_i_r_n_a_m_e
        The value is an absolute directory name.  This option can be
        used to change the location of the whole configuration
        structure, which can also be used for trying out Epos before
        installing it:


          cd src
          ./epos --base_dir ../cfg





     ----ppsseeuuddoo__rroooott__ddiirr ssll//ddiirrnnaammee//
        The value is a directory name.  Sets the path prepended to any
        file name referenced in the TTSCP ``stream command''. This
        subtree cannot be escaped with cute parent-of-root paths, but
        you can use symlinks to arbitrary accessible parts of the kernel
        name space, again, without giving access to the rest of the file
        system. Write access to this subtree to any user except Epos
        effectively gives him the privilege to use the Epos file access
        rights anywhere in the system through creating a symlink to the
        absolute root directory.



     ----iinnii__ddiirr _d_i_r_n_a_m_e
        The value is a directory name.  Sets the path to language
        independent configuration files.


     ----ffiixxeedd__iinnii__ffiillee _f_i_l_e_n_a_m_e
        The value is a file name.  This option can be used to change the
        file name of the fixed.ini file, which usually contains
        operating system independent, relatively fixed default global
        configuration.

     ----ccffgg__ffiillee _f_i_l_e_n_a_m_e
        The value is a file name. This option can be used to change the
        file name of the epos.ini file.
     ----wwaavvee__ffiillee _f_i_l_e_n_a_m_e
        The value is a file name. This option can be used to change the
        file name of the file produced by the play_diphones option. In
        many unices, setting this to /dev/dsp is the recommended way to
        actually hear Epos speak. Other unices don't have /dev/dsp,
        however.

     ----iinnppuutt__ffiillee _f_i_l_e_n_a_m_e
        The value is a file name. This option can be used to change the
        file name of the implicit input text used by the monolithic
        version of Epos.  The value is language dependent.

     ----nnnneett__ffiillee _f_i_l_e_n_a_m_e
        The value is a file name. This option can be used to change the
        file name of the file produced by the experimental neuronet
        option.

     ----ssttddddbbgg__ffiillee _f_i_l_e_n_a_m_e
        The value is a file name. This option can be used to change the
        file name whereto various debugging output should be written. If
        not set at all, stdout will be used.

     ----ssttddsshhrriieekk__ffiillee _f_i_l_e_n_a_m_e
        The value is a file name. This option can be used to change the
        file name whereto output unrelated to the usual output should be
        printed. It includes especially error messages.


     ----rruulleess__ddiirr _d_i_r_n_a_m_e
        The language dependent value is a directory name.  The directory
        shall contain the rules file.

     ----hhaasshh__ddiirr _d_i_r_n_a_m_e
        The language dependent value is a directory name.  The directory
        shall contain any dictionaries used by the rules.

     ----iinnppuutt__ddiirr _d_i_r_n_a_m_e
        The language dependent value is a directory name.  The directory
        shall contain the implicit input text file for the monolithic
        version of Epos.

     ----pprroossooddyy__ddiirr _d_i_r_n_a_m_e
        The language dependent value is a directory name.  The directory
        shall contain any prosody modelling related dictionaries used by
        the rules. FIXME: fakt? chci to tak?

     ----llaanngg__bbaassee__ddiirr _d_i_r_n_a_m_e
        The value is a global directory name, not a language dependent
        one.  It serves as the base directory for looking up the newly
        constructed languages.

     ----wwaavv__ddiirr _d_i_r_n_a_m_e
        The value is a global directory name.  Any waveform files
        created by Epos without explicit directory specification will be
        created in this directory.

     ----mmaattllaabb__ddiirr _d_i_r_n_a_m_e
        The value is a global directory name.  An input file for the
        experimental neural networks will be created in the directory
        when the neuronet option is on.  Its name is specified by the
        nnet_file option.





  33..77..99..  DDaaeemmoonn ssttaarrttuupp ooppttiioonnss


  The options in this section usually have no effect if changed in run
  time; change them in the configuration files instead.



     ----ddaaeemmoonn__lloogg _f_i_l_e_n_a_m_e
        The value is a file name. This option can be used to set the
        file where various information about the Epos process is
        recorded.  At the moment that is of little practical use except
        for debugging.

     ----aallllooww__ooppttiioonnss__ffiillee _f_i_l_e_n_a_m_e
        The file named by this parameter provides access control in
        TTSCP to individual options.  Its syntax is described ``above''.

     ----lliisstteenn__ppoorrtt _p_o_r_t
        The TCP port number where the daemon should be listening for
        incoming TTSCP connections. The daemon will check if no other
        service is already running on that port and refuses to run if
        the port is already occupied.



  33..77..1100..  DDeebbuuggggiinngg ooppttiioonnss


  Various kinds of debugging information can be printed by Epos.  The
  amount and topics of it can be reasonably tuned by a couple of
  options.  Most debugging information is printed throughout the code
  using the DEBUG macro; other sources or debugging information are not
  discussed in this subsection.  The DEBUG macro takes three parameters:
  the _c_o_d_e _a_r_e_a, the _s_e_v_e_r_i_t_y _l_e_v_e_l and the code to be executed if the
  severity level supplied is considered sufficient under current
  settings.  This code is usually a fprintf to the stddbg stream.  The
  decision whether to execute the debugging code, based on the code area
  and severity level is carried out by the debug_wanted function
  supplied in src/interf.cc.  You can either edit it yourself, or, you
  can use the options described in this section to control the behavior
  of the default debug_wanted function supplied by Epos.  Note that
  #define DEBUGGING must be enabled in interf.h, else the DEBUG macro is
  ignored altogether.

  The _l_e_v_e_l argument taken by many options in this subsection is a
  severity level number.

         |       |                      |                        |
         |________|_______________________|_________________________|_______
         |level  |  debugging messages  |  comment               |
         |________|_______________________|_________________________|_______
         |0      |  detailed            |  non-systematic chaos  |
         |1      |  verbose             |  too verbose           |
         |2      |  normal              |  informative           |
         |3      |  rare                |  warnings, and such    |
         |4      |  none                |  should not exist      |
         |________|_______________________|_________________________|_______


                             Severity levels





     ----uussee__ddeebbuugg
        This option must be on to provide any debugging information
        (except for daemon activity logging controlled by ``the
        daemon_log option''.

     ----aassssiimm__ddeebbuugg _l_e_v_e_l
        Severity level threshold for the code area of regress and
        related types of rules, as well as their implementation in the
        src/elements.cc file.

     ----ccffgg__ddeebbuugg _l_e_v_e_l
        Severity level threshold for the code area of parsing the Epos
        configuration .ini files.  A few instances in this area may not
        be handled properly, because they are called before this option
        is set itself. In this case, the default severity level
        threshold as found in the src/options.cc file.

     ----ddaaeemmoonn__ddeebbuugg _l_e_v_e_l
        Severity level threshold for the code areas of scheduling and
        TTSCP interpretation. This code is absent from the monolithic
        Epos.

     ----eelleemm__ddeebbuugg _l_e_v_e_l
        Severity level threshold for the code area of the ``text
        structure representation''.  This usually does not include code
        which is specifically written to support a particular rules
        type.

     ----iinntteerrff__ddeebbuugg _l_e_v_e_l
        Severity level threshold for the "interface" code area; that is,
        for assorted (usually) non-member functions, usually located in
        src/interf.cc. This is a catch-all area.

     ----ppaarrsseerr__ddeebbuugg _l_e_v_e_l
        Severity level threshold for the code area of parsing text to
        yield a ``text structure representation''.  It nearly coincides
        with the src/parser.cc file.

     ----rruulleess__ddeebbuugg _l_e_v_e_l
        Severity level threshold for the code area of parsing and
        application of the rules. This usually does not include any code
        which is rule type specific.

     ----sspplliitt__ddeebbuugg _l_e_v_e_l
        Severity level threshold for the code area of most types of
        rules, as well as their implementation in the src/elements.cc
        file.  This covers especially syllabification, diphonization and
        other structure manipulations.

     ----ssuubbsstt__ddeebbuugg _l_e_v_e_l
        Severity level threshold for the code area of subst and related
        types of rules, as well as their implementation in the
        src/elements.cc file

     ----ssyynntthh__ddeebbuugg _l_e_v_e_l
        Severity level threshold for the code area of low level speech
        syntheses (diphone to speech). It covers both individual
        algorithms and the common code.

     ----aallwwaayyss__ddeebbuugg _l_e_v_e_l
        The global positive severity level threshold. Any debugging code
        which reaches at least this severity level is executed
        regardless of the code area specific threshold. This option is
        especially useful for generic debugging, when the code area
        responsible for incorrect behavior is still unknown.

     ----lliimmiitt__ddeebbuugg _l_e_v_e_l
        The global negative severity level threshold. No debugging code
        which fails to reach at least this severity level is executed
        regardless of the code area specific threshold. This option is
        useful for setting up a global severity level threshold for most
        (non-focused) code areas.  Should the always_dbg and limit_dbg
        options come into conflict, the former takes precedence.

     ----ffooccuuss__ddeebbuugg _a_r_e_a
        The parameter is a code area to be excepted from the limit_dbg
        option.  This code area will obey its own severity level limit,
        even if the global negative limit is stricter.  The global
        positive severity level is however unaffected.  Every area uses
        the same name as in its corresponding severity level threshold
        option, without the _dbg suffix.



  44..  TTeexxtt--TToo--SSppeeeecchh CCoonnttrrooll PPrroottooccooll  ((TTTTSSCCPP))  ((vveerrssiioonn 11))


  TTSCP is a connection-oriented, both human- and machine-readable
  communication protocol, remotely similar to the File Transfer Protocol
  in spirit. It is designed to work atop TCP, but any reliable
  connection-oriented underlying protocol should theoretically work as
  well.

  The server is awaiting new connections on a single TCP port.  There
  are two types of connections: _c_o_n_t_r_o_l _c_o_n_n_e_c_t_i_o_n_s used to issue
  commands by the client and to return status information, such as
  completion messages by the server, and _d_a_t_a _c_o_n_n_e_c_t_i_o_n_s used to
  transfer the actual data.  A new connection is treated as a control
  connection, until the data command is issued by the client, causing it
  to become a data connection. A _T_T_S_C_P _s_e_s_s_i_o_n is a sequence of
  commands, their results and referenced data lasting from setting up
  the control connection until its disconnection or the data command.

  Any party may quit the session at any time, but must advise the other
  one either by the done command (the client) or by a 600 response code
  or higher (the server).  If a done command is sent before a preceding
  command has completed, the server will proceed with the preceding
  commands. If a 600 or higher error code is received as a response to a
  command and subsequent commands have already been sent by the client,
  they will not be executed.

  A typical TTSCP session looks like this, with client commands left-
  indented and server responses right-indented.



               TTSCP rev 1 spoken here
       user user@host.domain.net
               4xx user not found
       set option on
               200 OK
       strm $zC-4EEl0:raw:rules:diphs:synth:/dev/dsp
               200 OK
       appl 34
               112 started
               122 written bytes
                36
               200 OK
       done
               600 goodbye


  The "user" and "done" commands may become mandatory, the rest may be
  freely used between them. For the interaction with a human, the "help"
  command is available.

  The "brk" command currently stops the speech output for all the
  voices. This will change in the future.

  It is legal to use "anonymous" instead of the address in the user
  command: "user anonymous". It is also legal to switch users with
  additional user commands. This may cause context switches.

  It is advised to check the greeting string received to begin in
  "preTTSCP" or "TTSCP ". If it doesn't, the client or possibly the
  server may be obsolete.

  In this document, a "newline" produced by the client should be a
  single ASCII LF character, whereas the server should understand both
  LF and CR LF sequences as a single "newline". Subject to change.


  44..11..  DDaattaa ffoorrmmaattss


  The data is passed between modules in one of the following formats:


  +o  plain ASCII text

  +o  Spoken Text Markup Language (STML)

  +o  phonetic structure of the text

  +o  sequence of diphones

  +o  waveform file


  44..11..11..  PPllaaiinn AASSCCIIII tteexxtt

  Traditional.


  44..11..22..  SSTTMMLL

  As described in ???. Currently unimplemented.


  44..11..33..  TTeexxtt ssttrruuccttuurree rreepprreesseennttaattiioonn

  Internal text representation, suitable for arbitrary processing, but
  unsuitable for input or output. Before output, it must be converted to
  another format first. For a description, see the ``text structure
  representation overview''.

  Conversion to plain ASCII text dismisses prosody.

  Conversion to plain ASCII text or STML dismisses diphone layer if any.


  44..11..44..  SSeeqquueennccee ooff ddiipphhoonneess


  Every diphone is a quadruple of diphone number, assigned frequency
  (pitch), intensity (volume) and time factor (speed). The initial
  diphone is dummy (to be skipped); its diphone number contains the
  total number of diphones in this sequence. The corresponding prosodic
  parameters are undefined.  They should preferably be zero.

  FIXME: endianness, int size considerations


  44..11..55..  WWaavveeffoorrmm

  The traditional MS Windows .wav file header and data.  FIXME: more



  44..22..  TTTTSSCCPP CCoommmmaannddss


  TTSCP commands are newline-terminated strings. Each of them begins
  with a command identifier, some of them may continue with optional or
  mandatory parameters, depending on the particular command.  Each
  command generates one or more "replies", the last reply indicating
  completion and sometimes also some command-specific information.


  44..22..11..  aappppll


  Apply the current data processing stream (see the ``strm command'' to
  some data. The parameter is a decimal number specifying the number of
  bytes to be processed.

  Before the completion reply, a 122 reply is received by the client.
  It is followed by a decimal number on a line by itself, preceded with
  a single space. This is the number of bytes written by the output
  module. This intermediate reply should be sent as soon as the number
  of bytes to be sent is known to the TTSCP server to avoid certain
  deadlock scenarios caused by an insufficient buffer capacity between
  the server and the client. The number of bytes actually received may
  be even smaller in case of a user break or another unexpected
  situation.  In such cases, the behavior is (still) undefined; assume
  they never happen. FIXME: define it.

  The completion response code is received when all the modules have
  finished processing and data has been output by the output module.
  Some of the data may however still be being processed by hardware,
  e.g. a sound card, or may be delayed by the network.

  Using appl before the first strm command is forbidden.


  44..22..22..  bbrrkk


  Stop writing Signal into devices as soon as possible.  (This command
  may disappear in the future.)

  The only mandatory requirement is that there are no more speaking
  processes upon receiving a 2xx error code.


  44..22..33..  ddaattaa


  Turn this control connection into a data connection. The parameter, if
  any, is the desired connection handle. If no parameter is given, the
  server will supply a randomly generated handle.

  It is preferred to rely on server generated unique handles, especially
  in a networked environment. The client-supplied handle may be refused
  if it is already an existing data connection handle.  A complying
  server may choose to reserve some data connection handles for its
  internal use, to enforce a certain format for the handles, or to
  reject all client-supplied handles altogether.

  In reply to a data command without parameters, at least three lines
  are sent by the server. The first is a TTSCP reply announcing the
  forthcoming data connection handle (response code 142), immediately
  followed by the handle on a line by itself. (The handle is a newline-
  terminated string consisting of random alphanumeric, dash, and
  underline characters, case sensitive.)  The handle is preceded by a
  single space character, which is not part of the handle.  The third
  line is the completion reply (response code 200 if successful).  After
  the first newline character following the 200 response code is
  received, no more control information will arrive. Likewise, the
  client may not send any TTSCP commands after the newline-terminated
  data command.

  In reply to a data command with a client supplied connection handle,
  only the completion reply is received.

  If the data command is not successful, because the handle supplied is
  not unique or because of capacity reasons, the connection stays in a
  valid TTSCP control connection state and more commands may be
  submitted.

  The data connection becomes valid at receipt of a 200 response code to
  this command.


  44..22..44..  ddeellhh


  Terminate a specified data connection. The parameter is the data
  connection handle to be terminated, as returned by a former data
  command on that connection.  If successful, the connection is
  disconnected by the server and the data connection handle is
  forgotten.


  44..22..55..  ddoonnee


  Issued as the last command in a session. The client may exit just
  after sending this command. The server should reply with error code
  600.


  44..22..66..  ddoowwnn


  Stop the server. Quit pending sessions. May disappear in the future.


  44..22..77..  hheellpp


  Request for TTSCP syntax help. The server response is undefined except
  for the proper error code termination (class 2 or 4).

  Suggested behavior is to reply with "441 help yourself" or with no
  more than 24 lines of command resume.  If a parameter is given, the
  server may supply more specific information, such as verbose
  description of a single command.


  44..22..88..  ppaassss


  Attempts to validate an account, as given by a previous "user"
  command. If no valid "user" command was ever received, the internal
  server password may be used. This may enable some internal commands
  such as "reap".

  The password format is as yet unspecified. Work in progress.


  44..22..99..  rreeaapp


  Internal implementation only. This command is not required in any
  TTSCP implementation. On UNIX, this command is used to kill a thread
  specified by a pid given by its parameter.  The session must be
  validated to UID_SERVER before.

  Will be removed in future.


  44..22..1100..  ssaayy


  The parameter is a plain text. The server should process it and write
  the synthesized waveform to a device as configured.

  This command is obsolete and will disappear in the future.


  44..22..1111..  sseett


  Set a server configuration parameter. The parameter is of the form
  "option=value". The server may ignore this command altogether with an
  error code 442. In any case, this setting should never alter the
  execution environment of existing and/or future sessions.  The server
  will reply with an error code 412 if the value assigned is illegal, or
  with 451 if the server is configured not to allow to change this
  parameter (may depend on authentication status).

  If the option name is "language", the command will attempt to switch
  the language. The same goes for "voice".

  The official status of this command is still unclear.  It is
  definitely reasonable to use compatible option names between server
  implementations where applicable, but the set of useful configuration
  parameters is impossible to specify in advance.  Any comment on this
  issue is welcome.


  44..22..1122..  sshhooww


  Show a configuration parameter value. The parameter is an option name.
  The server may ignore this command with error code 442.  Subject to
  change.

  show languages and show voices may be used for listing available
  languages, as well as available voices for the current language.





  44..22..1133..  ssttrrmm


  Prepare a data flow stream. The parameter is a colon-separated
  sequence of data processing modules; commands such as appl cause
  specified data to be run through the modules from left to right.  Any
  two adjacent modules must be compatible, that is the type of output
  produced by the one to the left must match the type of input processed
  by the one to the right. The leftmost module must designate a source
  (input) module for the whole stream, the rightmost one must designate
  a destination for the data produced by the stream. Information on
  specific data formats accepted or produced by the modules can be found
  ``above''.

  The stream is not automatically active. It processes data only when
  requested by the ``appl'' command.

  The stream lasts until the next strm command or termination of the
  TTSCP connection, then it is deleted.


  44..22..1133..11..  IInnppuutt aanndd oouuttppuutt mmoodduulleess


  The input and output modules follow the same syntax conventions.  If
  the module name begins with a $, the rest of the name is a data
  connection handle. If it begins with a slash, it is an absolute file
  name.  Such absolute file names however form a name space distinct
  from that of the underlying system.  In Epos, the name space is a
  single directory defined by the pseudo_root_dir option.  It must be
  impossible to escape from the name space by inserting parent directory
  references in a file name or otherwise.



  The output data type of an input module and the input data type of an
  output module are determined by the respective adjacent modules. If
  input and output modules are directly connected, it is assumed that
  the data is a plain text.

  Some data types can not be sent or received or only with certain
  limitations.  This is not too well documented.




  44..22..1133..22..  PPrroocceessssiinngg mmoodduulleess


  At the moment there are only few modules implemented that do a real
  processing. All of them have fixed names and types.




  44..22..1133..33..  EExxpplliicciitt ddaattaa ttyyppee ssppeecciiffiiccaattiioonnss


  Sometimes an ambiguity concerning the type of data passed at a certain
  point within the stream may occur.  This is currently the case with
  streams consisting of input and output modules only (such as a stream
  to play out an audio icon from a waveform file to a sound card
  device); in the future, ambiguously typed versatile processing modules
  may be introduced, too.  Sometimes the data type is semantically
  irrelevant (for example, a socket-to-socket forwarding stream),
  sometimes the default data type, that is, a plain text, is a
  |       |                     |                        |                                    |
  |________|______________________|_________________________|_______________                      |
  |name   |  input data format  |  output data format    |  semantics                         |
  |________|______________________|_________________________|_______________                      |
  |raw    |  plain text         |  text structure        |  parses the text                   |
  |stml   |  STML text          |  text structure        |  parses STML                       |
  |rules  |  text structure     |  text structure        |  written-to-spoken conversion      |
  |print  |  text structure     |  plain text            |  drops suprasegmental information  |
  |diphs  |  text structure     |  diphones              |  extracts the diphone layer if any |
  |synth  |  diphones           |  waveform              |  speech synthesis proper           |
  |________|______________________|_________________________|_______________                      |


                       Available processing modules
  reasonable choice.  There are however instances where the type
  matters, like copying a waveform file to a sound card device: the
  waveform header must be stripped off and the appropriate ioctls must
  be issued to replay the raw waveform data with the appropriate
  sampling frequency, sample size and so on.

  The data types can be expressed explicitly by inserting a pseudo-
  module into the stream at the ambiguous position.  Failing that, the
  output data type of the preceding module and/or the input data type
  decides the data type at this point. Failing even that, the server
  will assume plain text data.

  The pseudo-module name consists of a single letter enclosed in square
  brackets.  The following letters represent the available data types:

       |      |
       |_______|__________________________________________________________
       |name  |  data format
       |_______|__________________________________________________________
       |t     |  plain text
       |s     |  STML text
       |i     |  the server-internal text structure representation
       |d     |  diphones
       |w     |  waveform
       |_______|__________________________________________________________


                      Explicit data type specifiers

  The data formats are described in ``the data formats subsection''.


  44..22..1144..  ttrraannss


  The parameter is a plain text. The server should process it and reply
  with its (phonetic) transcription.

  This command is obsolete and will disappear in the future.


  44..22..1155..  uusseerr


  Should precede all TTSCP exchanges. Its parameter is "anonymous" or a
  local or configured user account name. Some other user names may
  acquire special meaning. We'll see.

  Unless the account requires no authentication, this command should be
  immediately followed by a proper pass command; otherwise the session
  may be refused to issue most or all other commands.

  If no user command is issued, "user anonymous" is assumed.

  If the user doesn't exist, anonymous access is granted.

  The user command is still not implemented properly and its semantics
  may change.





  44..33..  rreessppoonnssee ccooddeess


  Any server _r_e_p_l_y contains a numeric code, a single space, and some
  arbitrary newline-terminated text. The numeric code (three decimal
  digits) allows interfacing with simple to trivial clients, whereas the
  text (which is optional) is meant for possible user interaction.

  The _r_e_s_p_o_n_s_e _c_o_d_e_s are defined by the protocol, while the accompanying
  text is not, but it should rarely exceed 20 characters (clients should
  tolerate at least 76 characters plus the response code).

  Every response code consists of the _r_e_s_p_o_n_s_e _c_l_a_s_s, _t_h_e _s_u_b_c_l_a_s_s and
  an extra digit. The response class drives the protocol states and
  reports errors. The subclass is interpreted depending on the response
  class; it can specify which component has reported an error or
  generated this particular response. Trivial clients may ignore this
  digit altogether. The third digit is merely used for distinguishing
  between messages of the same class and subclass and most clients are
  likely to ignore it in most situations.


  44..33..11..  rreessppoonnssee ccllaasssseess

  The response classes listed below are possible within TTSCP.

  |      |                                |                             |
  |_______|_________________________________|______________________________|
  |code  |  error type                    |  suggested action           |
  |_______|_________________________________|______________________________|
  |0xx   |  reserved                      |  (server queries client?)   |
  |1xx   |  still OK                      |  informative only           |
  |2xx   |  OK, command completed         |  transmit another command   |
  |3xx   |  warning, server still trying  |  notify user / ignore       |
  |4xx   |  command failed                |  transmit another command   |
  |5xx   |  reserved                      |  ignore                     |
  |6xx   |  connection terminated         |  notify user if unexpected  |
  |7xx   |  reserved                      |                             |
  |8xx   |  server crash or shutdown      |  notify user                |
  |_______|_________________________________|______________________________|


                          TTSCP response classes

  The client is expected to send another command whenever it receives a
  2xx or a 4xx response, not to send otherwise. The client should treat
  the connection as terminated, whenever it receives any response with
  code 5xx or higher. It may also quit at any time just after sending a
  "done" command to the server; the server will however confirm that
  command with a reply of 600 before disconnecting.

  Replies of 8xx except 800 are reserved for cases of severe server
  misconfiguration, or detected programming bugs. Their meanings are
  very implementation dependent (implementations are encouraged not to
  issue them except in emergency). If such a reply is ever received, the
  server has abnormally terminated.

  The messages accompanying 3xx and higher response codes are likely to
  be interesting to the user if any. Any message without an error code
  is a data flow primarily meant for the user if any; a sequence of
  these may occur only after some 1xx response, except for debugging
  messages if on.

  At the moment, some error codes contain letters. Later, all of them
  will consist of digits only and will be space-terminated.


  44..33..22..  rreessppoonnssee ssuubbccllaasssseess


  The subclass depends on the response class. The most interesting
  classes are 3xx and 4xx, i.e. errors, where the subclass indicates
  both the nature of the problem, and the suggested way of dealing with
  it (especially in the case of 4xx responses).  The same meaning is
  attached to these subclasses also in case of 6xx and 8xx responses.

  The middle digit of 1xx and 2xx responses has still no meaning
  attached (there are only a few such responses).

  |      |                 |                                            |
  |_______|__________________|_____________________________________________|
  |code  |  error type     |  suggested action                          |
  |_______|__________________|_____________________________________________|
  |0     |  none           |  relax; assume user-initiated interruption |
  |1     |  syntax         |  notify user                               |
  |2     |  busy           |  wait and retry                            |
  |3     |  data format    |  notify user                               |
  |4     |  not found      |  notify user                               |
  |5     |  access denied  |  notify user                               |
  |6     |  server error   |  have user notify server author            |
  |7     |  network error  |  wait and retry                            |
  |_______|__________________|_____________________________________________|


                          TTSCP error subclasses


  44..33..33..  ccuurrrreennttllyy ddeeffiinneedd mmeessssaaggeess


  Some of the following message codes are very unlikely to get through
  to the client and may therefore change meanings in future TTSCP
  descriptions. Any comment is welcome.

          |         |                                          |
          |__________|___________________________________________|_________
          |111      |  daemon talks                            |
          |112      |  apply task started                      |
          |121      |  transcription follows                   |
          |122      |  apply task returned bytes count follows |
          |141      |  option value follows                    |
          |142      |  data connection handle follows          |
          |__________|___________________________________________|_________
          |200      |  daemon is happy and ready               |
          |211      |  access granted                          |
          |212      |  anonymous access granted                |
          |__________|___________________________________________|_________


                  TTSCP success codes as issued by Epos

       |__________|__________________________________________________|_____
       |401      |  brk command received                           |
       |411      |  command not recognized                         |
       |412      |  option passed illegal value                    |
       |413      |  command too long, ignored                      |
       |414      |  parameter should be a non-negative integer     |
       |415      |  no or bad stream                               |
       |416      |  no parameter allowed                           |
       |421      |  output voice busy                              |
       |422      |  data connection handle already in use          |
       |431      |  unknown character in text                      |
       |432      |  received bad diphones                          |
       |441      |  help not available                             |
       |442      |  no such option                                 |
       |443      |  no such language or voice                      |
       |444      |  invalid data connection handle                 |
       |445      |  could not open file                            |
       |446      |  out of range                                   |
       |447      |  invalid option value                           |
       |448      |  cannot send woven pointery                     |
       |451      |  option not changeable                          |
       |452      |  no such user or bad password                   |
       |461      |  input triggered server bug                     |
       |462      |  unimplemented feature                          |
       |463      |  input triggered configuration bug              |
       |471      |  tcpsyn received invalid waveform               |
       |472      |  unknown remote tcpsyn server                   |
       |__________|__________________________________________________|_____
       |600      |  session ended normally                         |
       |661      |  generic scheduler bug                          |
       |662      |  stream sanity violation bug                    |
       |664      |  out of memory                                  |
       |665      |  error on close                                 |
       |671      |  client unreachable                             |
       |672      |  third party unreachable                        |
       |673      |  server unreachable                             |
       |674      |  server speaks unrecognized protocol            |
       |__________|__________________________________________________|_____
       |800      |  server shutting down as requested by client    |
       |801      |  error explicitly reported in config files      |
       |811      |  rules file syntax                              |
       |812      |  generic configuration file syntax              |
       |813      |  impossibilia referenced in config files        |
       |814      |  bad command line                               |
       |841      |  cannot open necessary configuration file       |
       |842      |  no voices configured                           |
       |861      |  internal error: impossible branch of execution |
       |862      |  internal error: invariance violation           |
       |863      |  internal error: buffer overflow                |
       |864      |  insufficient capacity                          |
       |869      |  double fault                                   |
       |871      |  network unreachable                            |
       |872      |  server already running                         |
       |__________|__________________________________________________|_____


                   TTSCP error codes as issued by Epos

  The 8xx class of responses (fatal errors) is still very unsettled and
  many of the codes listed there will later be removed or merged
  together. Applications should not try to decode them except possibly
  for the middle digit. The same goes for all x6x subclasses of errors
  (internal errors)



  55..  SSoouurrccee CCooddee DDooccuummeennttaattiioonn


  This section is of little use for anyone except for programmers
  willing to contribute to the development of Epos or going to modify
  its source code. It is also not trying to become a beginner's guide to
  Epos. Anyway, if you are personally missing something here or
  elsewhere, tell me and I may add it; that will become almost the only
  source of progress in this section of documentation. The section may
  also slowly become outdated due to lack of interest.


  55..11..  DDeessiiggnn ggooaallss


  Overall coding priorities, approximately in order of decreasing
  precedence:

  +o  language independence and generality

  +o  no undocumented or implicit "features"

  +o  portability

  +o  maintainability, clean decomposition

  +o  clean (intuitive) protocols and programming interfaces

  +o  scalability

  +o  intuitive configuration

  +o  fault tolerance

  +o  simple algorithms

  +o  code readability

  +o  speed

  +o  space

  +o  possible paralelizability


  55..22..  IIssoollaatteedd ccllaasssseess


  class parser, unit, rules, text and maybe a few others are isolated
  classes that take no advantage from inheritance. The reason for the
  class-oriented design is just a matter of code readability and
  decomposition in this case.


  55..22..11..  CCllaassss ssiimmpplleeppaarrsseerr


  This class takes some input (such as a plain ASCII or STML text) and
  then can be used in conjunction with the class unit constructor to
  build the ``text structure representation''. Its purpose is to
  identify the Latin text tokens (usually ASCII characters, but some
  traditional tokens like "..." would be difficult to identify later, as
  well as numerous other context dependent uses of "."). The parser also
  identifies the level of description which corresponds to the token and
  this is the information needed by the class unit constructor to
  correctly build the ``TSR''. In this process, the parser skips over
  any empty units, that is, units that contain no phones (simple
  letters) at all.

  Note that it is unnecessary and counterproductive to distinguish
  between homographic tokens used at the same level of description here;
  such intelligence can be handled more flexibly by the language
  dependent rules. In fact, they tend to be usually language dependent.
  The parser only avoids losing information (through empty unit
  deletion) by the minimum necessary tokenization.

  The STML parser is still unimplemented.


  55..22..22..  CCllaassss uunniitt


  This class is the fundamental element of the ``text structure
  representation''. Its methods are listed in elements.h.  Every object
  of this type represents a single text unit.  Every unit includes
  pointers to its immediate container, and to its contents. The contents
  are organized in a bidirectional linked list; pointers to the head and
  tail units of this lists are stored in the unit. These links, i.e.
  prev and next, also serve to locate the neighboring units; they may be
  NULL, indicating that this is the first/last unit in the immediate
  container.  For most uses, these pointers are not suitable to be used
  directly; the Prev and Next methods find the neighbor, even if a
  higher level boundary lies in between. It is also possible to mark a
  unit as a scope one. In this case, the Next and Prev methods will be
  unable to cross its boundary from inside out (they will return NULL if
  this is attempted).  If you need to modify the TSR directly, you will
  benefit from calling unit::sanity occasionally. This method checks the
  TSR structure near the unit which has called it and will report a
  severe error, if an invariant is violated, thus saving you from
  misguided error messages or crashes later.

  To extract the prosodic information from a TSR, call the effective
  method.  It will combine the prosodic adjustments present at all the
  levels of description above the current unit.


  55..22..33..  CCllaassss tteexxtt


  This class represents a logical line-oriented text file. It handles
  things like the ``#include directive'', ``backslash-escaped special
  characters'', initial whitespace and comment stripping. It is used for
  the ``rule files'' and ``configuration files'', but _n_o_t for the
  ``dictionaries''.


  55..22..44..  CCllaassss ffiillee


  This class represents a physical data file.  Its main purpose is to
  cache and share files repeatedly needed by Epos.  The claim function
  (to be found in interf.cc) should be used for opening the file (or
  only sharing an existing copy if the file is already open) and reading
  the data out of the file. The unclaim function is called separately
  for every claim call whenever the file is no more needed.

  Any code which uses this class should never extract the data member
  out of it and use it independently, even if the class itself remains
  claimed. This is because if the content of the file has changed, the
  data in memory will be reallocated and re-read upon the next call to
  claim or possibly even sooner. This may cause invalidation of the
  original data member at any point of a control switch to another Epos
  agent.  It is possible to call reclaim at any time to force re-reading
  any file if its time stamp has changed.


  55..22..55..  CCllaassss hhaasshh


  class hash is derived from class hash_table<char,char>.  The
  hash_table template is a generic hash table, keys and associated data
  items being its class parameters. This implementation uses balanced
  (AVL) trees to resolve collisions and is able to adjust (rehash)
  itself when it gets too full or too sparse. It is a very robust and
  fast implementation and it is independent of the rest of Epos, so you
  may use it in other projects if you want to (subject to GPL).  If you
  want to have the hash table keep a copy of its contents, the key
  and/or data may only be of a fixed size type, or a C-style string.
  Alternatively, the hash table will only store pointers to these items.
  These approaches can be mixed in any reasonable sense of "mixing".

  The hash tables are used frequently in Epos in various type
  combinations (see hash.cc for a list. They're also used for parsing
  the ``dictionary files''.


  55..22..66..  CCllaassss rruulleess


  Note the difference between class rules and class rule.  Every set of
  rules in Epos (there is one per language) is a class rules, which
  contains a single r_block, which in turn contains the individual
  rules.  The class rules serves as the only communication interface
  between the rule hierarchy and the rest of Epos, but there is no
  inheritance relation between them.




  55..33..  CCllaassss hhiieerraarrcchhiieess

  55..33..11..  CCllaassss rruullee


  Each rule object represents a rule to be applied to a structure of
  units. The class hierarchy:

  rule

  +o  r_regress

  +o  r_progress

  +o  r_raise

  +o  r_syll

  +o  r_contour

  +o  r_smooth

  +o  r_regex

  +o  r_debug

  +o  hashing_rule


  +o  r_subst

  +o  r_prep

  +o  r_postp

  +o  r_diph

  +o  r_prosody

  +o  cond_rule

  +o  r_inside

  +o  r_if

  +o  r_with

  +o  block_rule

  +o  r_block

  +o  r_choice

  +o  r_switch

  Classes not beginning in r_ can be considered abstract.


  55..33..22..  CCllaassss aaggeenntt


  Epos can be configured to support multiple simultaneous TTSCP
  connections and excepting bugs, no single unauthorized connection
  should be able to create a Denial of Service situation, such as long
  delays in processing other connections.  To achieve this, Epos uses a
  simple cooperative multitasking facility called _a_g_e_n_t_s. An agent
  (process) is an entity, which is responsible for carrying out some
  task, such as reading a few bytes from a file descriptor.  At any
  moment (except for the startup and the very moments of a transfer of
  control), exactly one agent is active (Epos doesn't support SMP to
  avoid the unnecessary overhead and complexity in the typical case).
  If an agent has to wait for some event before its job is finished, for
  example, when the sound card reaches full buffers or not enough data
  has arrived through a network connection, the agent calls the block
  method with the offending file descriptor.  It is impossible to wait
  for anything except a file descriptor status change.  If an agents
  wants to have another agent running, it can call the schedule method
  to add it to the queue of runnable processes. The scheduled agents
  always acquire control through the run method; when this method
  returns, another agent is chosen.  If there are no more runnable
  agents, Epos will wait until an agent becomes runnable through a
  status change of the file descriptor the agent is blocking for.

  Most agents get their data input through the inb data member and place
  their output into the outb data member. Whenever the agent has
  completed a stand-alone chunk of output, the agent calls the pass
  method to pass it to its successor and to schedule it for processing.
  The output agent never calls pass (it has actually no successor and it
  is responsible for writing the data somewhere outside Epos), but it
  calls finis when the data has been successfully written.

  Most agents are organized into streams of interconnected agents. See
  the ``strm command'' for the semantics of that.  Other agents are
  responsible for individual TTSCP connections, for accepting new
  connections and other tasks. A special agent is used for deleting
  other agents when they need to delete themselves.

  The current agents are:

  agent

  +o  stream

  +o  a_accept

  +o  a_protocol

  +o  a_ttscp

  +o  a_disconnector

  +o  a_ascii

  +o  a_stml

  +o  a_rules

  +o  a_print

  +o  a_diphs

  +o  a_synth

  +o  a_io

  +o  a_input

  +o  a_output

  +o  oa_ascii

  +o  oa_stml

  +o  oa_diph

  +o  oa_wavefm


  55..44..  MMoorree iinnffoorrmmaattiioonn


  The header files mostly define basic interfaces for individual Epos
  components.  Reading the ones related to a specific piece of code may
  often clarify things.  Lots of global data declarations live in
  common.h; others (especially small, library-like functions) can be
  found in interf.h.

  If you have any code or development related question about Epos, send
  it to the Epos development mailing list epos@braille.mff.cuni.cz.
  Please spend a few seconds by trying to look up the answer in the
  documentation first.










