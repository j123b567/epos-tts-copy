
Tento soubor je urèen pouze tìm, kdo mají v úmyslu modifikovat nebo
ve vlastních programech vyuívat tøídu hash (hashovací tabulky).


Co momentálnì hashovací tabulky umí
-----------------------------------

"Hashování (krkolomnì druhdy zváno "methoda transformace klíèe") jest
 zpùsob, jak vìtšího mnoství neuspoøádanıch dat v memoráøi uloiti
 a v èase hbitém, ba s mnostvím nemìnném, k datu veškeren pøístup míti."
			(Repetitorium školy mateøské, J.A. Comenius)

Tato implementace hashovacích tabulek pro ošetøení kolizí pouívá
vyvaované AVL stromy, a je mono ji nastavit, aby se sama
pøehashovala, pakli hloubka stromu nebo koeficient zaplnìní pøesáhne
urèitou mez, nebo naopak pokud zaène bıt velmi øídká.

Kadá poloka v tabulce sestává z klíèe a s ním asociovanıch dat.
Klíè a data mohou bıt buïto objekty nebo øetìzce (ne nutnì toté).
Klíè se pouívá k vyhledávání, data se pouze vezou.

Podporované operace v zásadì jsou pøidání poloky, vyhledání poloky
(vstup: klíè; vıstup: data, pokud byl nalezen), odstranìní existující
poloky a seslání zvenku poskytnuté funkce na všechny poloky.

Oèekává se ovšem, e je-li klíè objektem, nikoli øetìzcem, e má
korektnì fungující operátor "-" (vrací nulu v pøípadì logické 
shodnosti klíèù a nebo kladné èi záporné èíslo tak, aby se choval
asymetricky a transitivnì, tj. analogicky jako strcmp) a dále
operátor pøetypování na unsigned int, kterı slouí jako vıchodisko
pro hashovací funkci, to jest musí dávat stejnou hodnotu pro logicky
shodné klíèe a pokud mono rùznou hodnotu pro klíèe rùzné; 
je vhodné, aby se tento operátor choval deterministicky, ale pøitom
co nejnepøedvídatelnìji. 

Dále jak klíè, tak data, jsou-li objektem, musí disponovat korektním
copy constructorem, kterı se pouije pro vytvoøení lokální kopie pøi
pøidávání do tabulky. Leda, e by uivatel chtìl, aby si tabulka
nevytváøela vlastní kopie objektù - zejména pokud jde o objekty
trvalé, jejich existenci po dobu uloení v tabulce zajišuje sám.
V takovém pøípadì je nutno po vytvoøení prázdné tabulky vypnout
(vynulovat) její poloky "dupkey" èi "dupdata", jak je zapotøebí.

Pokud je nutné udrovat poloky uspoøádané, je to moné. Vynutí se to 
sníením kapacity tabulky na jedinı prvek a zakázáním automatického
pøehashovávání. Základní operace se pak provádìjí v O(log n_poloek)
a tabulka vlastnì slouí jako AVL strom.


Co lze hashovat
---------------

Jediná zmìna, která mì pøimìla zmìnit èíslo verze z 1.x na 2.x, je
pøepracování tøídy hash na template hash_table <key_t, data_t>,
a pak odvození hash ze tøídy hash_table <char, char>. Take pokud
nìkdo chce hashovat tøeba øetìzce na struct history, nadeklaruje
si hash_table <char, history> name. Øetìzce jsou definovány tak,
e je jejich sizeof() roven jedné; délka øetìzce je pak dána funkcí
strlen(). 

Z verze 2.0 na 2.1 se zmìnilo chování pøi hashování struktur.
K jejich kopírování se pouívá copy constructor, to jest za normálních
okolností pùjde o default copy constructor. Pokud však struktura slouí
jako klíè, musí mít dále definován operátor binární minus a pøetypování
na unsigned int slouící jako neomezené hashovací funkce (viz vıše pro
popis).

Ve verzi 2.2 je navíc mono vypnout kopírování a klíèe nebo dat úplnì.
K tomu staèí po vytvoøení tabulky, ale pøed vloením prvního prvku
vynulovat její èlen dupkey anebo dupdata. V takovém pøípadì musí
uivatel zajistit existenci hashovaného objektu tak dlouho, dokud
není vyjmut z tabulky.

Kdy u jsme u té historie, ve verzi 2.3 pøibylo ošetøení escape
sekvencí pøi naèítání tabulky z textového souboru (backslash + znak
-> znak). Viz poslední parametr pøíslušného konstruktoru.


Pøehashovávání
--------------

Pokud chceš, aby se tabulka pøehashovala, kdykoli si umane (to by tøeba
u real-time aplikace vadilo), je jí to potøeba øíci. Kadá tabulka má dva
èíselné argumenty, které uvádìjí (v procentech) míru pøeplnìní a naopak
minimální míru zaplnìní, pøi jejím pøekroèení (podkroèení) se tabulka
celá pøehashuje. Tyto parametry se udávají buïto jako argumenty nìkterıch
konstruktorù, nebo je lze kdykoli nastavit pomocí metody cfg_rehash().
Analogicky lze nastavit maximální hloubku kolizního stromu, která rovnì
vyvolá pokus o pøehashování. Tabulka se vdy pøehashuje tak, aby koeficient
zaplnìní byl roven opìt dalšímu parametru (v procentech).

Implicitní hodnoty jsou: optimální míra zaplnìní 60%, smí se pohybovat
v rozmezí 0 - 400%, kolizní strom nesmí dosáhnout hloubky 6. Pøípadnı
upsizing pøi tìchto hodnotách lze oèekávat spíše kvùli pøeplnìní, ne
kvùli náhodnému vzniku pøíliš hlubokému stromu. Tyto hodnoty povauji
za praktické i tam, kde je potøeba maximalizovat rychlost základních
operací.

Vnìjší program mùe o pøehashování poádat explicitnì funkcí rehash().
Jedinım parametrem je nová kapacita tabulky, k momentálnímu poètu
prvkù se nepøihlédne. Pokud není ádnı parametr uveden, tabulka se pøehashuje
na rozmìr, kterı zrovna povauje za optimální podle momentálního poètu
prvkù.

Pokud by se pøi pøidávání prvkù zjistilo, e tabulka by se vlastnì mìla
zmenšit, protoe byla pøedtím umìle zvìtšena funkcí rehash(), pøehashovávat
se nebude, protoe aplikace asi vìdìla, proè ji zvìtšuje. Analogicky, pøi
ubírání prvku se tabulka mùe zmenšit, ale ne zvìtšit. Pøi vyhledávání
prvku se tabulka zásadnì nemìní.


Ukládání do souboru
-------------------

Následující funkce se tıkají pouze tøídy hash, to jest je nutno
hashovat øetìzce na øetìzce, ale nikoli skrze hash_table <char, char>.

Je-li pøi vstupu do hash.cc definován symbol HASH_CAN_READ_FILES,
pøibude jeden konstruktor, konstruující tabulku z textového souboru,
a dvì funkce write() a update(). Tento cirkus lze vyuívat pouze
pokud je klíè i data typu øetìzec.

Textovı soubor mùe vypadat napø. takto:

klíè1 data1
klíè2	data2
# komentáø
klíè3	s_daty	; a s komentáøem

Kadı øádek odpovídá (nejvıše) jedné poloce. Díváme-li se na nìj jako
na posloupnost slov oddìlenıch mezerami èi tabelátory (lze míchat
a pøiøazením do globální promìnné WHITESPACE lze pouít úplnì jiné
oddìlovaèe), tvoøí poloku slova a po poslední, které ještì nezaèíná
oddìlovaèem komentáøe (implicitnì støedník nebo double cross, lze mìnit
pøiøazením do promìnné COMMENT_LINES). Je-li tìchto slov nula, øádka
se pøeskoèí, jsou-li dvì, bude vytvoøena pøíslušná poloka v hashovací
tabulce.

Šestı parametr souborového konstruktoru urèuje, jak bude naloeno
s øádky, které obsahují pouze jedno slovo. Moné hodnoty jsou
DATA_OBLIGATORY, to jest pokyn k havárii, DATA_EQUALS_KEY, to jest
je tøeba v takovém pøípadì toto slovo povaovat jak za klíè, tak za data
a dále libovolnı øetìzec, kterı se pouije jako implicitní hodnota dat
pro tento pøípad.

Sedmı parametr souborového konstruktoru urèuje, co se stane, jsou-li
na øádku tøi nebo více slov - true znamená, e druhé a poslední slovo
budou interpretovány jako víceslovná data, false znamená, e program
havaruje s chybovım hlášením.

Pøedposlední, osmı parametr pak urèuje, jaké chybové hlášení se má vhodit
do funkce shriek(), pokud se soubor nepodaøí otevøít. Je-li tento parametr
NULL, pouije se vestavìná hodnota. Je-li roven konstantì ANYWAY, bude
v takovém pøípadì vytvoøena mrtvì narozená hashovací tabulka; není vùbec
definováno, jak se bude chovat, pouze, e poloka "items" bude rovna minus
jedné, a e pùjde provést její defaultní destruktor.

A poslední devátı parametr, není-li NULL, je pøekladová tabulka
pro escape sekvence, to jest objeví-li se na øádce zpìtné lomítko,
zaindexuje se znakem, kterı následuje za zpìtnım lomítkem do této
tabulky a vyloví se odpovídající znak, kterım se zpìtné lomítko
s následujícím znakem nahradí. Pokud o zvláštní chování zpìtného
lomítka není zájem, staèí místo tohoto parametru uvést NULL.
Jinak musí bıt tabulka 256 znakù dlouhá. Tuto funkci lze kombinovat
se zpìtnım vıstupem do souboru jen omezenì.

Ostatní parametry souborového konstruktoru jsou jednak jméno souboru,
jednak parametry kontrolující automatické pøehashovávání.

Funkce write() zapíše danou hashovací tabulku do uvedeného souboru.
Z pùvodního souboru nechá jen hlavièku (komentáøové øádky pøedcházející
první skuteènou poloku), nevyaduje jeho existenci. Dojde-li k chybì,
nebo je-li o to poádána druhım argumentem, nebude po dokonèení operace
smazán záloní soubor, kterı má shodné jméno s tildou (vlnovkou) 
pøipojenou na zaèátek. Novı soubor ovsahuje poloky seøazené abecednì.
Funkce write() nijak neovlivòuje vlastní tabulku.

Funkce update() upraví uvedenı soubor podle hashovací tabulky. Pùvodní
soubor musí bezpodmíneènì existovat a jeho struktura, pokud jde o uspo-
øádání poloek nebo umístìní komentáøù je zachována, mìní se pouze
hodnoty. Pokud soubor obsahuje nìjaké poloky navíc oproti hashovací
tabulce, jsou vyhozeny nebo zachovány podle parametru remove_removed.
Pokud v souboru nìkteré poloky naopak schází, jsou pøipojeny na jeho
konec. Funkce update() nièí veškerı obsah hashovací tabulky, zbyde
prázdná tabulka. Pokud by toto chování vadilo, lze metodu update()
sesílat pouze na kopii vytvoøenou copy constructorem.

Je závanou chybou, e tyto dvì zápisové funkce pøedpokládají bìnı
obsah promìnné WHITESPACE. Nebo u ne?

Ve tøídì hash lze funkcemi add_int() a translate_int() vkládat
a vyhledávat i dvojice øetìzec-èíslo. Èíslo se representuje
v desítkové soustavì, jak je zvykem; s tím je mono míchat
øetìzce a èísla.

Pokud se hashují øetìzce na cokoli, poloka longest obsahuje poèet
znakù nejdelšího klíèe, kterı vùbec kdy uvnitø bydlel. Mùe se nìkdy
hodit zvenku vìdìt, co já vím.

Tato implementace hashovací tabulky je pomìrnì nároèná na pamì.
Uchovává si mimo jiné strukturu sestávající ze short intu a ètyø
ukazatelù pro kadou poloku (searchtreestruct). To moná nìkdy
zkusím zlepšit vzhledem k tomu, e dva z tìch pointerù nabıvají
nenulovıch hodnot jen pøi kolizích.

Funkce translate() i funkce remove() vracejí pointer pøímo na vnitøní
kopii v tabulce; v pøípadì translate() nesmí volající tuto pamì uvolnit,
v pøípadì remove() naopak musí.

Hashovací tabulka jako taková je velice rychlá, take pojede na rychlosti
malloc() a free(). Funkce translate() nikdy nemìní obsah tabulky, take
ta nebude zdrovaná vùbec a nejvíc èasu nejspíš stráví ve fn() (privátní
inline metoda poèítající hashovací funkci).

Funkce debug() vypíše obsah tabulky, pokud se hashují øetìzce na øetìzce.

Tento soubor zhruba dokumentuje stav v létì 1998.

